#!/bin/bash
# izSynth - TTS/Text To Speech synthesizer, background music overlay assembler and audio file converter for PBX and Home Automation Systems
# Home Page: http://www.initzero.it/products/opensource/izsynth
# Written by: Ugo Viti <ugo.viti@initzero.it>
#
# izSynth is a bash script running under Linux, written to automate the synthesis of voices used into izPBX System or for realtime TTS (Text To Speech) used into Home Automation solutions.
# It can use offline synthesis software like Loquendo (using the Wine environment), eSpeak, Festival, VoiceRSS, NaturalReaders, and other popular online web TTS services
# to synthesize audio voices from ASCII text files and automatically merging the audio with background music (mp3 and wav format are supported), adding silences and fade in and out.
#
# For INSTALL, LICENSE, README, HowTo, ChangeLog and Contributors go to the end of this script

###########################################################################################
# script variables
NAME="izsynth"
DESCRIPTION="TTS/Text To Speech synthesizer, background music overlay assembler and audio file converter for PBX and Home Automation Systems"
VERSION="4.2"
VERSION_DATE="20160510"

#####################################
## default suggested user variables to change 
## you can put these variables into $HOME/.config/izsynth/izsynth.conf to override the script variables

# default TTS engine
TTS_ENGINE="naturalreaders"

# default TTS voice (null = let TTS engine to set default voice. it will use english)
TTS_VOICE="Peter"

# playback instead generate PBX files
PLAYBACK="yes"

# remove synthesized file after playback
PLAYBACK_REMOVE="no"

# play the file in background, otherwise foreground
PLAYBACK_BACKGROUND="yes"

# resynth the file if it already exist
PLAYBACK_RESYNTH="no"

# sound card playback volume
#PLAYBACK_VOLUME="30"

# command used to play the synthehtized audio file
PLAYBACK_COMMAND="mplayer -ao alsa -really-quiet -nolirc -noconsolecontrols"

###########################################################################################
## system variables - edit with care

# default mandatory commands
COMMANDS="curl md5sum file iconv soxi sox lame"

# default audio formats
AUDIO_FORMATS_PBX="44khz.wav wav gsm ulaw alaw slin"

# default base temp directory (comment if you want use the system default directory base, ex. /tmp)
TMP_DIR_BASE="/dev/shm"

# default redirect to tmp dir
OUT_DIR="$TMP_DIR_BASE"

# default TTS volume
#TTS_VOLUME="0.4"

# default wait n. seconds before speaking TTS
TTS_PAD_BEGIN="5"

# default wait n. seconds after speaked TTS
TTS_PAD_END="5"

# default start music after n. seconds
MUSIC_START="0"

# default fade the start and end of music with 5 seconds
MUSIC_FADE="5"

# default music volume
#MUSIC_VOLUME="0.1"

# split destination audio files into audio formats sub directories
SPLIT_OUT_FILE="no"

# read external izsynth config file (used for service API and external variables override)
IZSYNTH_CONFIG_DIR="$HOME/.config/$NAME"
IZSYNTH_CONFIG_FILE="$IZSYNTH_CONFIG_DIR/$NAME.conf"
# make default izsynth config directory
[ ! -e "$IZSYNTH_CONFIG_DIR/engines" ] && mkdir -p "$IZSYNTH_CONFIG_DIR/engines"
[ -e "$IZSYNTH_CONFIG_FILE" ] && . "$IZSYNTH_CONFIG_FILE"

###########################################################################################
# main script - don't edit anything bellow
###########################################################################################

# START TTS ENGINES
# add others TTS engines here

tts_engine_ispeech() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"


  case $ACTION in
        description)
                echo "2016-05-03 Remote iSpeech NO Custom http://www.ispeech.org"
                ;;
        help)
                echo "this engine is limited to 160 chars max"
                ;;
        env)
                # default output file format
                TTS_EXT="mp3"
		# default max allowed chars
		TTS_LENGTH="150"
                # default TTS voice
                [ -z "$TTS_LANGUAGE" ] && TTS_LANGUAGE="English"
                [ -z "$TTS_VOICE" ] && TTS_VOICE="English"
                ;;
        commands)
                echo "curl"
                ;;
        voices)
                # extract languages and voices list and make the output using the following command:
		#curl -s http://www.ispeech.org/html/tts-demo.php | grep "<li class=\"voices\" id=\"" | awk -F "['']" '{print $2" "$3}' | awk -F "[><]" '{print $1" "$4}' | sed 's/&nbsp;//g' | sed 's/);"//g' | column -c1 -t
		echo "Voice                Country     Language    Gender"
		echo "-------------------- ----------- ----------- ------"
		echo "usenglishfemale      US          English     Female
usenglishmale        US          English     Male
ukenglishfemale      UK          English     Female
ukenglishmale        UK          English     Male
auenglishfemale      Australian  English     Female
usspanishfemale      US          Spanish     Female
usspanishmale        US          Spanish     Male
chchinesefemale      China       Chinese     Female
hkchinesefemale      HongKong    Catonese    Female
twchinesefemale      Taiwan      Chinese     Female
jpjapanesefemale     Japan       Japanese    Female
krkoreanfemale       Korea       Korean      Female
caenglishfemale      Canadian    English     Female
huhungarianfemale    Hungary     Hungarian   Female
brportuguesefemale   Brazilian   Portuguese  Female
eurportuguesefemale  European    Portuguese  Female
eurportuguesemale    European    Portuguese  Male
eurspanishfemale     European    Spanish     Female
eurspanishmale       European    Spanish     Male
eurcatalanfemale     European    Catalan     Female
eurczechfemale       European    Czech       Female
eurdanishfemale      European    Danish      Female
eurfinnishfemale     European    Finnish     Female
eurfrenchfemale      European    French      Female
eurfrenchmale        European    French      Male
eurnorwegianfemale   European    Norweigian  Female
eurdutchfemale       European    Dutch       Female
eurpolishfemale      European    Polish      Female
euritalianfemale     European    Italian     Female
euritalianmale       European    Italian     Male
eurturkishfemale     European    Turkish     Female
eurturkishmale       European    Turkish     Male
eurgreekfemale       European    Greek       Female
eurgermanfemale      European    German      Female
eurgermanmale        European    German      Male
rurussianfemale      Russia      Russian     Female
rurussianmale        Russia      Russian     Male
swswedishfemale      Sweden      Swedish     Female
cafrenchfemale       Canadian    French      Female
cafrenchmale         Canadian    French      Male
arabicmale           Dubai       Arabic      Male"
                ;;
        voice)
                eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | awk '{print $1}'
                ;;
        synthesize)
                local TTS_STRING_CONTENT="$(urlencode "$(cat "$IN" | parse_tts_string)")"
                local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"

		curl -s "http://www.ispeech.org/p/generic/getaudio?text=$TTS_STRING_CONTENT&voice=$TTS_VOICE&speed=0&action=convert" -o "$OUT"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}


tts_engine_google() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
        description)
                echo "2016-05-01 Remote GoogleVoice NO Google http://translate.google.com"
                ;;
        help)
                echo "this engine is limited to 160 chars max"
                ;;
        env)
                # default output file format
                TTS_EXT="mp3"
		# default max allowed chars
		TTS_LENGTH="150"
                # default TTS voice
                [ -z "$TTS_VOICE" ] && TTS_VOICE="en"
                ;;
        commands)
                echo "curl"
                ;;
        voices)
		echo "af  Afrikaans
sq  Albanian
am  Amharic
ar  Arabic
hy  Armenian
az  Azerbaijani
eu  Basque
be  Belarusian
bn  Bengali
bh  Bihari
bs  Bosnian
br  Breton
bg  Bulgarian
km  Cambodian
ca  Catalan
zh-CN Chinese (Simplified)
zh-TW Chinese (Traditional)
co  Corsican
hr  Croatian
cs  Czech
da  Danish
nl  Dutch
en  English
eo  Esperanto
et  Estonian
fo  Faroese
tl  Filipino
fi  Finnish
fr  French
fy  Frisian
gl  Galician
ka  Georgian
de  German
el  Greek
gn  Guarani
gu  Gujarati
ha  Hausa
iw  Hebrew
hi  Hindi
hu  Hungarian
is  Icelandic
id  Indonesian
ia  Interlingua
ga  Irish
it  Italian
ja  Japanese
jw  Javanese
kn  Kannada
kk  Kazakh
rw  Kinyarwanda
rn  Kirundi
ko  Korean
ku  Kurdish
ky  Kyrgyz
lo  Laothian
la  Latin
lv  Latvian
ln  Lingala
lt  Lithuanian
mk  Macedonian
mg  Malagasy
ms  Malay
ml  Malayalam
mt  Maltese
mi  Maori
mr  Marathi
mo  Moldavian
mn  Mongolian
sr-ME Montenegrin
ne  Nepali
no  Norwegian
nn  Norwegian (Nynorsk)
oc  Occitan
or  Oriya
om  Oromo
ps  Pashto
fa  Persian
pl  Polish
pt-BR Portuguese (Brazil)
pt-PT Portuguese (Portugal)
pa  Punjabi
qu  Quechua
ro  Romanian
rm  Romansh
ru  Russian
gd  Scots Gaelic
sr  Serbian
sh  Serbo-Croatian
st  Sesotho
sn  Shona
sd  Sindhi
si  Sinhalese
sk  Slovak
sl  Slovenian
so  Somali
es  Spanish
su  Sundanese
sw  Swahili
sv  Swedish
tg  Tajik
ta  Tamil
tt  Tatar
te  Telugu
th  Thai
ti  Tigrinya
to  Tonga
tr  Turkish
tk  Turkmen
tw  Twi
ug  Uighur
uk  Ukrainian
ur  Urdu
uz  Uzbek
vi  Vietnamese
cy  Welsh
xh  Xhosa
yi  Yiddish
yo  Yoruba
zu  Zulu" | sort | column -c1 -t
                ;;
        voice)
                eval ${FUNCNAME} voices | grep -w -- "$VOICE" | head -n1 | awk '{print $1}'
                ;;
        synthesize)
                local TTS_STRING_CONTENT="$(urlencode "$(cat "$IN" | parse_tts_string)")"
                local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"
                curl -s -G "http://translate.google.com/translate_tts?ie=UTF-8&total=1&idx=0&client=tw-ob&&tl=$TTS_VOICE&q=$TTS_STRING_CONTENT" -A "Mozilla" --compressed -o "$OUT"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}


tts_engine_voicerss() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"


  case $ACTION in
        description)
                echo "2016-04-18 Remote VoiceRSS YES Custom http://www.voicerss.org"
                ;;
        help)
                echo "Get the VoiceRSS API KEY from: http://www.voicerss.org/personel"
                echo "and put the following variable info '$IZSYNTH_CONFIG_FILE' config file:"
                echo
                echo "VOICERSS_APIKEY=yourapikey"
                ;;
        env)
                # default output file format
                TTS_EXT="mp3"
                # default TTS voice
                [ -z "$TTS_LANGUAGE" ] && TTS_LANGUAGE="English"
                [ -z "$TTS_VOICE" ] && TTS_VOICE="English"
                ;;
        commands)
                echo "curl"
                ;;
        voices)
                # extract languages and voices list and make the output
                curl -s "http://www.voicerss.org/api/demo.aspx" | grep "option value=" | grep -v "value=\"\"" | awk -F \" '{print $2 $3}' | awk -F "[><]" '{print $1" "$2}'
                ;;
        voice)
                eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | awk '{print $1}'
                ;;
        synthesize)
                local TTS_STRING_CONTENT="$(urlencode "$(cat "$IN" | parse_tts_string)")"
                local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"
                [ -z "$VOICERSS_APIKEY" ] && print_help_config && exit 1

                curl -s "http://api.voicerss.org/?key=$VOICERSS_APIKEY&src=$TTS_STRING_CONTENT&f=44khz_16bit_mono&hl=$TTS_VOICE" -o "$OUT"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}

tts_engine_naturalreaders() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
	description)
		echo "2015-12-19 Remote NaturalReader YES Custom http://www.naturalreaders.com"
		;;
	help)
		echo "No help available for $TTS_ENGINE"
		;;
	env)
		# default output file format
		TTS_EXT="mp3"
		# default TTS voice
		[ -z "$TTS_VOICE" ] && TTS_VOICE="en"
		;;
	commands)
		echo "curl"
		;;
	voices)
		# extracted from www.naturalreaders.com on 2015-12-19
		echo "1:  US Mike
11: US Crystal
14: US Ray
17: US Lauren
13: US Rich
16: US Julia
18: US Mel
15: US Claire
33: US Ryan
26: US Healter
29: US Laura
2:  UK Charles
3:  UK Audrey
31: UK Peter
32: UK Rachel
25: UK Graham
30: UK Lucy
4:  UK Anjali
7:  French Alain
8:  French Juliette
22: French Bruno
21: French Alice
5:  German Reiner
6:  German Klara
20: Spanish Rosa
19: Spanish Alberto
10: Italian Giovanni
12: Italian Francesca
34: Arabic Salma
40  Arabic Mehdi"
		;;
        voice)
		eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | tr -d [:cntrl:] | awk -F: '{print $1}'
                ;;
	synthesize)
		#local TTS_STRING_CONTENT="$(cat "$IN" | tr ' ' '+' | tr '\n' '+')"
		local TTS_STRING_CONTENT="$(urlencode "$(cat "$IN" | parse_tts_string)")"
		local TTS_SPEED=0
		local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"
		local REQUESTTOKEN="$(curl -s -G "http://api.naturalreaders.com/v2/auth/requesttoken?appid=pelc790w2bx&appsecret=2ma3jkhafcyscswg8wgk00w0kwsog4s" | awk -F":" '{print $3}' | tr -d [:punct:])"

		curl -s -G "http://api.naturalreaders.com/v2/tts/?t=$TTS_STRING_CONTENT&r=$TTS_VOICE&s=$TTS_SPEED&requesttoken=$REQUESTTOKEN" -o "$OUT"
		;;
	*)
		echo "${FUNCNAME}: wrong method called - abort"
		exit 1
		;;
  esac
}


tts_engine_fromtexttospeech() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
	description)
		echo "2015-12-19 Remote FromtextToSpeech NO IVONA http://www.fromtexttospeech.com"
		;;
	help)
		echo "No help available for $TTS_ENGINE"
		;;
	env)
		# default output file format
		TTS_EXT="mp3"
		# default TTS voice
		[ -z "$TTS_LANGUAGE" ] && TTS_LANGUAGE="English"
		[ -z "$TTS_VOICE" ] && TTS_VOICE="English"
		;;
	commands)
		echo "curl"
		;;
	voices)
                curl -s http://www.fromtexttospeech.com | grep "voice_indexes\['" | awk -F = '{print $2}' | sed '/^$/d' | sed "s/ '//" | sed "s/';//"
		;;
        voice)
		eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | tr -d [:cntrl:] | awk -F: '{print $1}'
                ;;
	synthesize)
		local TTS_STRING_CONTENT="$(cat $IN)"
		local TTS_SPEED=0
		local TTS_LANGUAGE="$(eval ${FUNCNAME} voice $VOICE | awk -F "[()]" '{ for (i=2; i<NF; i+=2) print $i }')"
		local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"
                #debug
		local ENGINE_URL="http://www.fromtexttospeech.com"

                local OUTPUT_FIlE="$(curl -s 'http://www.fromtexttospeech.com/' --data-urlencode "input_text=$TTS_STRING_CONTENT" --data-urlencode "language=$TTS_LANGUAGE" --data-urlencode "voice=$TTS_VOICE" --data "speed=$TTS_SPEED&action=process_text" | grep "href='/output/" | sed -n "/href='/s/.*href='\([^>]*\)'.*/\1/p")"
		curl -s $ENGINE_URL$OUTPUT_FIlE -o "$OUT"

		;;
	*)
		echo "${FUNCNAME}: wrong method called - abort"
		exit 1
		;;
  esac
}

tts_engine_festival() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
        description)
                echo "2015-12-19 Local Festival NO OpenSource http://www.cstr.ed.ac.uk/projects/festival"
                ;;
        help)
                echo "No help available for $TTS_ENGINE"
                ;;
        env)
                # default output file format
                TTS_EXT="wav"
                # default TTS voice
                [ -z "$TTS_VOICE" ] && TTS_VOICE="nitech_us_slt_arctic_hts"
                ;;
        commands)
                echo "text2wave"
                ;;
        voices)
                echo "festival voices list not supported"
                echo "run 'festival' command and type: (voice.list)"
                echo "CTRL-D to exit"
                echo "configure the desired language into ~/.festivalrc"
                ;;
        voice)
                #eval ${FUNCNAME} voices 2>&1 | grep -w "^$VOICE$"
                echo nitech_us_slt_arctic_hts
                ;;
        synthesize)
                cat "$IN" | text2wave -o "$OUT"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}



tts_engine_espeak() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
	description)
		echo "2015-12-19 Local eSpeak NO OpenSource http://espeak.sourceforge.net"
		;;
	help)
		echo "No help available for $TTS_ENGINE"
		;;
	env)
		# default output file format
		TTS_EXT="wav"
		# default TTS voice
		[ -z "$TTS_VOICE" ] && TTS_VOICE="en"
		;;
	commands)
		echo "espeak"
		;;
	voices)
		espeak --voices | awk '{print $2}' | grep -v ^Language$
		;;
        voice)
                eval ${FUNCNAME} voices 2>&1 | grep -w -- "^$VOICE$"
                ;;
	synthesize)
		espeak -w $OUT -v $TTS_VOICE -f $IN
		;;
	*)
		echo "${FUNCNAME}: wrong method called - abort"
		exit 1
		;;
  esac
}


tts_engine_sapi5() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
        description)
                echo "2015-12-19 Local SAPI5 NO Microsoft http://www.microsoft.com/en-us/download/details.aspx?id=10121"
                ;;
	help)
		echo "To use $TTS_ENGINE you must install:"
		echo "- wine (to run Windows applications inside Linux) from http://www.winehq.org/"
		echo "- Microsoft-English-TTS-51.msi (SAPI5 Speech SDK 5.1) from https://www.microsoft.com/en-us/download/details.aspx?id=10121"
		echo "- sapi2wav.exe (Synth and save TTS wav files using Windows SAPI library) from https://gitlab.mister-muffin.de/josch/novel2audio/raw/master/sapi2wav.exe"
		echo "- Buy and install commercial TTS engines for Windows SAPI environment, like Loquendo and IVONA voices"
		;;
	env)
		# default output file format
		TTS_EXT="wav"
		# default TTS voice
		[ -z "$TTS_VOICE" ] && TTS_VOICE="Giulia"
		;;
	commands)
		echo "sapi2wav.exe"
		;;
	voices)
		sapi2wav.exe -list 2>&1 | grep -v "wineboot.exe"
		;;
	voice)
		eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | tr -d [:cntrl:] | awk -F: '{print $1}'
		;;
	synthesize)
                # convert utf-8 text file to iso-8859-15
                local IN_FILE_ISO8859="$TMP_DIR/$(basename "$IN")"
                iconv --to-code ISO-8859-15 "$IN" -o "$IN_ISO8859" 

		sapi2wav.exe "$OUT" "$(eval ${FUNCNAME} voice $VOICE)" -f "$IN_ISO8859" 2>&1 | grep -v "wineboot.exe"
		;;
	*)
		echo "${FUNCNAME}: wrong method called - abort"
		exit 1
		;;
  esac
}


# END TTS ENGINES
###########################################################################################

# load all external engines
tts_engines_load() {
  for engine in $(find "$IZSYNTH_CONFIG_DIR/engines/" -name "*.conf") ; do . $engine ; done
}

# list all supported engines
tts_engines_list(){
  print_tts_engines_table() {
  echo "Engine            Version     Type    Provider          APIKEY  Technology  HomePage"
  echo "----------------  ----------  ------  ----------------  ------  ----------  --------"
  tts_engines_load
  typeset -f | awk '/ \(\) $/ && !/^main / {print $1}' | grep "^tts_engine_" | sed 's/^tts_engine_//g' | while read engine
   do
     echo -n -e "$engine $(tts_engine_$engine description)\n"
   done
  }
  print_tts_engines_table | column -c1 -t
}


# urlencode <string>
urlencode() {
    local LANG=C
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%%%02X' "'$c" ;; 
        esac
    done
}

# remove all new lines, double white spaces and ending spaces to avoid problems when encoding url
parse_tts_string() {
  tr '\n' ' ' | sed 's/  \+/ /g' | sed 's/^[ \t]*//;s/[ \t]*$//'
}

# because some engines allow only limited string length, we must count how many chars we have and pass only the max allowed to the engine
count_chars() {
  tr -d '[:space:]' | wc -c
}


print_help_config() {
  echo "ERROR: Wrong or missing $NAME user config file.

Step 1: Create this file: $IZSYNTH_CONFIG_FILE
Step 2: Put into all variables you want override from the main script
Step 3: $TTS_ENGINE specific config and variables:
"
  tts_engine_${TTS_ENGINE[$ID]} help
}

# print orizontal line with the given lenght
rulem()  {
  if [ $# -eq 0 ]; then
    echo "Usage: rulem MESSAGE WIDTH [RULE_CHARACTER]"
    return 1
  fi
  # Fill line with ruler character ($3, default "-"), reset cursor, move 2 cols right, print message
  if [ -z "$3" ] ; then
     printf -v _hr "%*s" $(tput cols) && echo -en ${_hr// /${2--}} && echo -e "\r\033[2C$1"
   else
     printf -v _hr "%$3s" && echo -en ${_hr// /${2--}} && echo -e "\r\033[2C$1"
  fi
}

# verify if the given variable is an array
is_array() {
    [[ "$(declare -p $1 2>/dev/null)" =~ "declare -a" ]]
}

# show mime type of a file (long version)
show_mime() {
  file --mime-type -b "$@"
}

# show mime type of a file (brief version)
show_mime_brief() {
  file --mime-type -b "$@" | awk -F"/" '{print $1}'
}

# show size of a file
show_size() {
  du -sh "$@" 2>/dev/null | awk '{print $1}'
}

# the name tell all :)
synthesize_file() {
  local IN="$1"
  shift
  local OUT="$1"

  # tts_engine_* destination_file 
  echo -e -n "Synthetizing - input:[$IN] engine:[${TTS_ENGINE[$ID]}] voice:["${TTS_VOICE[$ID]}"] output:[$OUT] "

  tts_engine_${TTS_ENGINE[$ID]} synthesize "${TTS_VOICE[$ID]}" "$IN" "$OUT"

  echo -e -n "size:[$(show_size "$OUT")] type:[$(show_mime "$OUT")] result:"

  if [[ $? = 0 && "$(show_mime_brief "$OUT")" == "audio" ]]
    then
      echo -e -n "[SUCCESS]\n"
    else
      echo -e -n "[ERROR]\n"
      exit 1
  fi
}

# playback the synthesized file
play_file () {
  local IN="$1"

  [ ! -z "$PLAYBACK_VOLUME" ] && PLAYBACK_COMMAND_OPTS="-volume $PLAYBACK_VOLUME"

  # if we must remove the synthesized file, of course we can't remove it if PLAYBACK_BACKGROUND=yes
  [ "$PLAYBACK_REMOVE" = "yes" ] && PLAYBACK_BACKGROUND="no"

  echo "Playing      - input:[$IN]"

  if [ "$PLAYBACK_BACKGROUND" = "yes" ]
    then
      $PLAYBACK_COMMAND $PLAYBACK_COMMAND_OPTS "$IN" &
    else
      $PLAYBACK_COMMAND $PLAYBACK_COMMAND_OPTS "$IN"
  fi

  # if required, remove the synthesized file
  [ "$PLAYBACK_REMOVE" = "yes" ] && echo "Removing     - input:[$IN]" && rm -f "$OUT"
}

# save the file in the output directory
save_file() {
  local IN="$1"
  shift
  local OUT="$1"

  echo "Saving       - input:[$IN] size:[$(show_size "$IN")] output:[$OUT]"
  cp -f "$IN" "$OUT"
}

# convert the input file to wav format
convert_file() {
  local IN="$1"
  shift
  local OUT="$1"
 
  case "$(print_ext $IN)" in
   mp3)
    echo -e -n "Converting   - input:[$IN] input_size:[$(show_size "$IN")] "
    lame --quiet --resample 44.1 --decode "$IN" "$OUT" 2>&1 | grep -v "Can't step back"
    echo -e -n "output:[$OUT] output_size:[$(show_size "$OUT")]\n"
    # let the converted wav file the input file
    IN="$OUT"
    ;;
  esac

  #debug

  # normalize the converted file
  # calc the sample rate of input audio file and convert the input audio file to the best usable sample rate (44100Hz) before processing and mixing with background music
  local IN_SR="$(soxi -r $IN)"
  if [ "$IN_SR" != 44100 ]
    then
      # change the destination file because decome 44100hz frequency
      OUT="$(print_path $OUT)/$(print_name $OUT)-44khz.wav"
      # convert to wav 44100 hz the wav file
      sox $SOX_OPTS "$IN" -r 44100 "$OUT"
      local RETVAL=$?
      local OUT_SR="$(soxi -r $OUT)"
      echo "Normalizing  - input:[$IN] input_size:[$(show_size "$IN")] input_rate:[$IN_SR] output_size:[$(show_size "$OUT")] output_rate:[$OUT_SR]"
      # replace the original 22.5khz with the 44.1khz version
      [ $RETVAL = 0 ] && mv -f "$OUT" "$IN"
  elif [[ ! -e "$OUT" || "$IN" != "$OUT" ]]
     then
      cp -a "$IN" "$OUT"
  fi
}

# convert the input file to the asterisk pbx supported formats
convert_file_pbx() {
  local IN="$1"
  shift
  local OUT_DIR="$1"

  local AUDIO_FORMAT
  local SOX_OPTS_FORMAT

  for AUDIO_FORMAT in $AUDIO_FORMATS_PBX
    do
      # set the destination pbx file name
      if [ "$SPLIT_OUT_FILE" = "yes" ]
        then
          mkdir -p "$OUT_DIR/$AUDIO_FORMAT"
          OUT="$OUT_DIR/$AUDIO_FORMAT/$(print_name $IN).$AUDIO_FORMAT"
        else
          OUT="$OUT_DIR/$(print_name $IN).$AUDIO_FORMAT"
      fi

      case $AUDIO_FORMAT in
                44khz.wav)
                        SOX_OPTS_FORMAT="-t wav -r 44100"
                        ;;
                wav)
                        SOX_OPTS_FORMAT="-t wav -r 8000"
                        ;;
                gsm)
                        SOX_OPTS_FORMAT="-t gsm -r 8000"
                        ;;
                ulaw)
                        SOX_OPTS_FORMAT="-t ul -r 8000"
                        ;;
                alaw)
                        SOX_OPTS_FORMAT="-t al -r 8000"
                        ;;
                slin)
                        SOX_OPTS_FORMAT="-t raw -r 8000"
                        ;;
      esac

      # convert to pbx formats
      sox -V1 $SOX_OPTS "$IN" $SOX_OPTS_FORMAT "$OUT" remix 1

      # display log informations
      echo "Saving PBX   - input:[$IN] output:[$OUT] size:[$(show_size "$OUT")] type:[$(show_mime "$OUT")]"
  done
}

# remix the file adding background music and audio effects
remix_file() {
  local IN="$1"
  shift
  local OUT="$1"

  # set sox options
  [ ! -z "$TTS_VOLUME" ] && SOX_OPTS="$SOX_OPTS -v $TTS_VOLUME"
  [ ! -z "$MUSIC_VOLUME" ] && SOX_OPTS_MUSIC="$SOX_OPTS_MUSIC -v $MUSIC_VOLUME"

  # calc the total time duration of input audio file
  let local IN_DURATION="$(soxi -s "$IN")/$(soxi -r "$IN")+$TTS_PAD_BEGIN+$TTS_PAD_END"

  #debug

  if [ ! -z "$MUSIC_FILE" ]
    then
      let local TTS_PAD_BEGIN_REAL="$MUSIC_START+$TTS_PAD_BEGIN"
      # mix tts voice with background music
      sox -V1 $SOX_OPTS_MUSIC -m "$MUSIC_FILE" "| sox $SOX_OPTS $IN -p pad $TTS_PAD_BEGIN_REAL" "$OUT" trim $MUSIC_START fade h $MUSIC_FADE $IN_DURATION $MUSIC_FADE remix 1
      echo "Remixing     - input:[$IN] music:[$MUSIC_FILE] music_volume:[$MUSIC_VOLUME] tts_volume:[$TTS_VOLUME] output:[$OUT] size:[$(show_size $OUT)] duration:[$IN_DURATION]"
    else
      # remix without background music
      sox -V1 $SOX_OPTS "$IN" "$OUT" remix 1
      echo "Remixing     - input:[$IN] tts_volume:[$TTS_VOLUME] output:[$OUT] size:[$(show_size $OUT)]"
  fi
}

# concatene all input files in a big file
megamix_file() {
  local OUT="$1"
  sox $SOX_OPTS "${IN_FILE_MEGAMIX[@]}" "$OUT"
  echo "Megamixing   - input:[${IN_FILE_MEGAMIX[@]}] output:[$OUT] size:[$(show_size $OUT)]"
}


# temp file management
make_tmp() {
  # the main synbak temp directory base name
  TMP_NAME="$NAME-$(date +"%Y%m%d-%H%M%S")"

  # a better way to manage temp directories
  if [ -z "$TMP_DIR_BASE" ]
    then
      TMP_DIR="$(mktemp -d -t "${TMP_NAME}" 2>/dev/null)"
      # for old systems that doesn't understand 'mktemp -t' option
      [ $? -eq 1 ] && TMP_DIR="/tmp/${TMP_NAME}" && mkdir -p "${TMP_DIR}"
      local TMP_DIR_BASE=/tmp
    else
      # make the final temp directory
      TMP_DIR="${TMP_DIR_BASE}/${TMP_NAME}" && mkdir -p "${TMP_DIR}"
  fi

  # change current directory to the temporary directory and make the backup from there
  if [ ! -d "${TMP_DIR}" ] && [ ! -w "${TMP_DIR}" ]
    then
      echo "ERROR: the directory '${TMP_DIR}' doesn't exist" >&2
      echo >&2
      exit 1
  fi
}


check_tts_engine() {
  # verify if the specified TTS engine exist
  if [ -z "$(tts_engines_list | grep -w "$1")" ] 
    then
 	echo "ERROR: wrong TTS engine synthesizer specified: '$1'"
	echo
	echo "please select an engine from the following list:"
	echo
	tts_engines_list
	exit 1
  fi
}

check_ver() {
    printf "%03d%03d%03d%03d" $(echo "$@" | tr '.' ' ')
}

check_env() {
  # definig all global variables

  # verify if all commands are installed in the system paths
  #for COMMAND in $COMMANDS $(tts_engine_$TTS_ENGINE commands)
  #  do
  #    which $COMMAND >/dev/null 2>&1
  #    [ $? -ne 0 ] && echo "ERROR: the command '$COMMAND' doesn't exist in any path, please install it and retry" && exit 1
  #  done

  # compatibility workarounds
  local SOX_VER="$(sox --version | awk '{print $3}' | tr -d '[:alpha:]')"
  if [ $(check_ver $SOX_VER) -ge $(check_ver 14.4.0) ]
   then
     #echo "Versione SOX attuale: $SOX_VER"
     SOX_OPTS="-G"
  fi

  # load any external TTS engines
  [ -e "$IZSYNTH_CONFIG_DIR/engines/$TTS_ENGINE.conf" ] && . "$IZSYNTH_CONFIG_DIR/engines/$TTS_ENGINE.conf"

  # import global tts_engine variables
  tts_engine_$TTS_ENGINE env #>/dev/null 2>&1

  # set default variables
  [ -z "$PLAYBACK_RESYNTH" ] && PLAYBACK_RESYNTH="yes"

  # check if no args are given and make some sanity checks
  [[ -z "${TTS_STRING}" &&   -z "${IN_FILE}" ]] && echo "ERROR: no text STRING/FILE/DIRECTORY specified, use '-t' or '-i' option - abort." >&2 && exit 1

  # make an input file where paste the given text string
  [ -n "$TTS_STRING" ] &&  IN_FILE=("$TMP_DIR/$(echo "$TTS_STRING" | sed -e 's/[^A-Za-z0-9_-]/_/g' | cut -c-64).txt") && echo "$TTS_STRING" > "$IN_FILE"

  #if is_array IN_FILE ; then echo IN_FILE Ã¨ un array; fi
  #[[ -z "${TTS_STRING}" && ! -f "${IN_FILE}" && ! -d "${IN_FILE}" ]] && echo "ERROR: ${IN_FILE}: invalid input file/directory - abort." >&2 && exit 1

  # if input file is a directory then process all files creating the main array
  if [ -d "${IN_FILE}" ]
    then
      # when input is a directory we never magamixing
      MEGAMIX="no"
      IN_FILE_ARRAY=($(find "$IN_FILE" -maxdepth 1 -type f))
    else
      # parse IN_FILE array and recreate special variables
      IN_FILE_ARRAY=("${IN_FILE[@]}")
  fi

  # destroy IN_FILE and recreate the array
  #echo IN_FILE_ARRAY=${IN_FILE_ARRAY[*]}
  unset IN_FILE

  # recreate the array parsing the command line
  ID=0 ; for IN in ${IN_FILE_ARRAY[@]}; do
   let ID+=1
   if echo "$IN" | grep ":" >/dev/null 2>&1
    then
     # parse input files when provided with megamix syntax
     TTS_ENGINE[$ID]="$(echo "$IN" | awk -F ":" '{print $1}')"
     TTS_VOICE[$ID]="$(echo "$IN" | awk -F ":" '{print $2}')"
     IN_FILE[$ID]="$(echo "$IN" | awk -F ":" '{print $3}')"
     #echo ID: $ID - ${IN_FILE[$ID]}
    else
     # parse input files when provided with default syntax
     TTS_ENGINE[$ID]="$TTS_ENGINE"
     TTS_VOICE[$ID]="$TTS_VOICE"
     IN_FILE[$ID]="$IN"
   fi

   # verify if the specified input file exist
   [ ! -e "${IN_FILE[$ID]}" ] && echo "ERROR: '${IN_FILE[$ID]}' invalid input file/directory - abort." >&2 && exit 1
  done

  # TTS_LENGTH auto splitting feature
  # recreate the array if the engine have chars limit, splitting the input file into many sub files
  if [ ! -z "$TTS_LENGTH" ]; then
     #for ((ID=1;ID<=${#IN_FILE[@]};ID++)); do
     ID=0 ; for IN in ${IN_FILE[@]}; do
      if [ "$(print_ext $IN)" = "txt" ]; then
       let ID+=1
       # destroy the original input file and use the splitted version
       unset IN_FILE[$ID]
       #echo
       #echo ID=$ID IN_FILE=${IN_FILE[@]}
       #echo ID=$ID IN_FILE_ARRAY=${IN_FILE_ARRAY[@]}
       TTS_LENGTH_CUR="$(cat "$IN" | parse_tts_string | count_chars)"
       if [ $TTS_LENGTH_CUR -ge $TTS_LENGTH ]; then
         MEGAMIX="yes"
         split_tts_file "$IN" $ID
        else
         TTS_ENGINE[$ID]="${TTS_ENGINE[$ID]}"
         TTS_VOICE[$ID]="${TTS_VOICE[$ID]}"
         IN_FILE_SPLIT+=($IN)
       fi
      fi
    done

    # recreate again the array with all engines, voices and splitted input files
    if [ ! -z "${IN_FILE_SPLIT[*]}" ]; then
     ID=0 ; for IN in ${IN_FILE_SPLIT[@]}; do
      let ID+=1
       # fix me, this doesn't works very well when using the special input file filter: engine:voice:file
       [ -z "${TTS_ENGINE[$ID]}" ] && TTS_ENGINE[$ID]="$TTS_ENGINE"
       [ -z "${TTS_VOICE[$ID]}" ] && TTS_VOICE[$ID]="$TTS_VOICE"
       IN_FILE[$ID]="$IN"
     done
    fi
  fi

  #echo IN_FILE_SPLIT[@] = ${IN_FILE_SPLIT[@]}
  #echo       IN_FILE[@] = ${IN_FILE[@]}

  #exit

  #debug
  #echo ${#IN_FILE[@]}
  #echo ${IN_FILE[@]}
  #echo ${IN_FILE[*]}
  #echo ${IN_FILE}
  #echo ${TTS_ENGINE[*]}
  #exit 1

  # verify if a music file is given and the file exist
  [[ ! -z "$MUSIC_FILE" && ! -e "$MUSIC_FILE" ]] && echo "ERROR: the music file '$MUSIC_FILE' doesn't exist or isn't readable" && exit 1

  # use MUSIC_VOLUME as TTS_VOLUME when MUSIC_FILE and TTS_VOLUME is not specified
  [[ -z "$MUSIC_FILE" && -z "$TTS_VOLUME" && ! -z "$MUSIC_VOLUME" ]] && TTS_VOLUME="$MUSIC_VOLUME"

  # we will use the tmp base dir for reusability porpouse, because we will speak the audio soound using the internal soundcard and the sintetized audio
  # will be used directly again if exist
  [ -z "${OUT_DIR}" ] && OUT_DIR="$TMP_DIR_BASE" && echo "INFO: no output directory specified, redirecting playback to system soundcard"
  [ ! -d "${OUT_DIR}" ] && echo "ERROR: invalid output directory specified: '${OUT_DIR}' - abort."      >&2 && exit 1
  [ ! -w "${OUT_DIR}" ] && echo "ERROR: not writable output directory specified: '${OUT_DIR}' - abort." >&2 && exit 1

  # if we give a music file, or change the output volume then remix always
  [[ ! -z "$MUSIC_FILE" || ! -z "$TTS_VOLUME" ]] && REMIX="yes" || REMIX="no"

  # if you pass more that one file as input then megamix them
  [[ "$MEGAMIX" != "no" && ${#IN_FILE[@]} -ge 2 ]] && REMIX="yes" && MEGAMIX="yes"

}

split_tts_file() {
  local IN="$1"
  shift
  local ID="$1"

  echo "INFO: Maximun allowed chars reached for engine ${TTS_ENGINE[$ID]}. allowed:$TTS_LENGTH - current:$TTS_LENGTH_CUR"

  SID=0 ; while read string ; do
   let SID+=1
   TTS_ENGINE[$SID]="${TTS_ENGINE[$ID]}"
   TTS_VOICE[$SID]="${TTS_VOICE[$ID]}"
   local IN_FILE_SPLIT_TMP="$TMP_DIR/$(print_name "$IN")-$SID.$(print_ext "$IN")"
   IN_FILE_SPLIT+=($IN_FILE_SPLIT_TMP)
   #echo -e -n "$IN_FILE_SPLIT_TMP " ; echo $string 
   echo $string > "$IN_FILE_SPLIT_TMP"
  done < <(echo -e -n "$(cat "$IN" | parse_tts_string | fold -sw $TTS_LENGTH)\n")
  #debug
}

# file name manupilation
print_path() {
  echo ${@%/*}
}

print_fullname() {
  echo ${@##*/}
}

print_name() {
  print_fullname $(echo ${@%.*})
}

print_ext() {
  echo ${@##*.}
}


debug() {
  echo "
IN_FILE ARRAY FIRST VALUE = $IN_FILE'
IN_FILE ARRAY ALL VALUES  = ${IN_FILE[@]}

IN_FILE_MEGAMIX ARRAY FIRST VALUE = $IN_FILE_MEGAMIX'
IN_FILE_MEGAMIX ARRAY ALL VALUES  = ${IN_FILE_MEGAMIX[@]}

other variables: 
================
     TMP_DIR = $TMP_DIR
         PWD = $PWD
          IN = $IN
         OUT = $OUT
TTS_LANGUAGE = $TTS_LANGUAGE
   TTS_VOICE = $TTS_VOICE
     IN_FILE = $IN_FILE
    OUT_FILE = $OUT_FILE
     OUT_PBX = $OUT_PBX
     OUT_DIR = $OUT_DIR
       REMIX = $REMIX
     MEGAMIX = $MEGAMIX
"
}

assemble_file() {
  local IN="$1"
  shift
  local OUT="$1"

  # local variables
  local OUT_TMP="$TMP_DIR/$(print_name $IN).wav"
  local OUT_TMP_REMIXED="$TMP_DIR/$(print_name $IN).remixed.wav"
  local OUT_TMP_MEGAMIXED="$TMP_DIR/$(print_name $IN).megamixed.wav"

  case "$(print_ext $IN)" in
    txt)
      # verify if the specified TTS engine is supported
      [[ -z "${TTS_ENGINE[$ID]}" || ! -z "$(check_tts_engine ${TTS_ENGINE[$ID]})" ]] && echo "ERROR: the TTS Engine '${TTS_ENGINE[$ID]}' doesn't exist, or is not supported by the $NAME" && exit 1

      # verify if the selected TTS voice is supported by the TTS engine
      [[ -z "${TTS_VOICE[$ID]}" || -z "$(tts_engine_${TTS_ENGINE[$ID]} voice ${TTS_VOICE[$ID]})" ]] && echo "ERROR: the TTS voice '${TTS_VOICE[$ID]}' doesn't exist, or is not supported by the engine '${TTS_ENGINE[$ID]}'" && exit 1

      #local TTS_FILE="$TMP_DIR/${TTS_ENGINE[$ID]}-${TTS_VOICE[$ID]}-$(print_name $IN).$TTS_EXT"
      local TTS_FILE="$TMP_DIR/$(print_name $IN).$TTS_EXT"
      if [[ "$REMIX" = "yes" || "$PLAYBACK" = "no" ]]; then
        synthesize_file "$IN" "$TTS_FILE"
       else
        # to speed up the playback process don't convert and use the wav version, directly use the tts_engine encoding instead
        synthesize_file "$IN" "$OUT"
      fi
      IN="$TTS_FILE"
      ;;
  esac

  # to speed up the playback process don't convert and use the wav version, directly use the tts_engine encoding instead
  if [[ "$REMIX" = "yes" || "$PLAYBACK" = "no" ]]; then
   case "$(print_ext $IN)" in
    txt|wav|mp3)
      # convert and normalize all given files
      convert_file "$IN" "$OUT_TMP"

      # if not megamixing, remix and save all single files
      if [ "$MEGAMIX" != "yes" ]
       then
        [ "$REMIX" = "yes" ] && remix_file "$OUT_TMP" "$OUT_TMP_REMIXED"
        [ "$REMIX" = "yes" ] && save_file  "$OUT_TMP_REMIXED" "$OUT" || save_file "$OUT_TMP" "$OUT"
       else
        # save into this global array all files to megamix (synthesized files and input wav/mp3 files)
        IN_FILE_MEGAMIX[$ID]="$OUT_TMP"
        # if this is the last file on megamix array, then make all remixing
        if [ $ID = ${#IN_FILE[@]} ]
         then
          rulem " [$ID/${#IN_FILE[@]}] " - 80
          megamix_file "$OUT_TMP_MEGAMIXED"
          remix_file "$OUT_TMP_MEGAMIXED" "$OUT_TMP_REMIXED"
          save_file  "$OUT_TMP_REMIXED" "$OUT"
       fi
      fi
      ;;
    *)
      echo "ERROR: Invalid file extension found: $(print_ext $IN) input:[$IN]"
      exit 1
      ;;
   esac
  fi
}

# all begin here
main() {
  # disable system wide command aliases if configured
  unalias mv cp 2>/dev/null

  # make temporary files
  make_tmp

  # verify the enveropment if all is good before starting conversion
  check_env

  # convert music file before assembling
  if [[ ! -z "$MUSIC_FILE" && "$(print_ext $MUSIC_FILE)" != "wav" ]]
   then
    convert_file "$MUSIC_FILE" "$TMP_DIR/$(print_name $MUSIC_FILE).wav"
    MUSIC_FILE="$TMP_DIR/$(print_name $MUSIC_FILE).wav"
  fi

  # assemble all given files processing array contents
  if [ "$MEGAMIX" != "yes" ] ; then
   ID=0 ; for IN in "${IN_FILE[@]}"; do
    let ID+=1
    #debug

    rulem " [$ID/${#IN_FILE[@]}] - $NAME Name:[$(print_name $IN)] " = 80

    if   [ "$PLAYBACK" = "yes" ]; then
      # to speed up the playback process don't convert and use the wav version, directly use the tts_engine encoding instead
      [ "$REMIX" = "yes" ] && local OUT="$OUT_DIR/$(print_name $IN).wav" || local OUT="$OUT_DIR/$(print_name $IN).$TTS_EXT"
     else
      local OUT="$TMP_DIR/$(print_name $IN).wav"
    fi

    if [[ -e "$OUT" && "$PLAYBACK_RESYNTH" = "no" ]]
      then
        echo "File exist   - input:[$OUT]"
        #echo "File exist   - input:[$OUT] size:[$(show_size "$OUT")]"
        # resynth the audio file only if the previous saved file was corrupted or with wrong format
        [ "$(show_mime_brief "$OUT")" != "audio" ] && assemble_file "$IN" "$OUT"
      else
        assemble_file "$IN" "$OUT"
    fi

    if  [ "$PLAYBACK" = "yes" ]; then
        play_file "$OUT"
      else
        convert_file_pbx "$OUT" "$OUT_DIR"
    fi
    rulem " [$ID/${#IN_FILE[@]}] " - 80
   done
  else
   #debug
   # the megamix file name is always taken from the first input name
   [ "$PLAYBACK" = "yes" ] && local OUT_MEGAMIX="$OUT_DIR/$(print_name ${IN_FILE[1]}).wav" || local OUT_MEGAMIX="$TMP_DIR/$(print_name ${IN_FILE[1]}).wav"

   if [[ ! -e "$OUT_MEGAMIX" || "$PLAYBACK_RESYNTH" = "yes" ]]
      then
        # remix all given files in one big file
        ID=0 ; for IN in "${IN_FILE[@]}"; do
         let ID+=1
         rulem " [$ID/${#IN_FILE[@]}] - $NAME Name:[$(print_name $IN)] == MEGAMIX " = 80
         assemble_file "$IN" "$OUT_MEGAMIX"
         rulem " [$ID/${#IN_FILE[@]}] " - 80
        done
   fi
   #debug

   if [ "$PLAYBACK" = "yes" ]
    then
     play_file "$OUT_MEGAMIX"
    else
     convert_file_pbx "$OUT_MEGAMIX" "$OUT_DIR"
   fi
 fi
}

usage_examples() {
echo "$NAME usage examples:
--------------------------------------------------------------------------------
# simple command line using script default variables (must set PLAYBACK=yes into $NAME to works)
$NAME Hello World. This is a test message

# sinthesize using standard input as source, useful when using an external command piped to $NAME
echo \"Welcome home, mr Stark\" | $NAME -

# sinthesize using standard input as source, and adding other $NAME options
echo Good morning boss | $NAME -w -m /tmp/music.mp3 -P 10 -F 7 -

# specifing engine and language and reusing the synthesized file for every run (much faster execution)
$NAME -e "$TTS_ENGINE" -v "$TTS_VOICE" -t \"This is only a test\"

# same example but resynthesizing every time the text and overwriting the destination file
$NAME -e "$TTS_ENGINE" -v "$TTS_VOICE" -t \"This is only a test\" -w

# change the output soundcard volume to 80%
$NAME -e "$TTS_ENGINE" -v "$TTS_VOICE" -t \"This is only a test\" -w -W 80

# batch creating the pbx's audio file using an input txt file
$NAME -i /tmp/src/company-welcome.txt -o /tmp/dst -m /tmp/music.mp3 -e "$TTS_ENGINE" -v "$TTS_VOICE" -p 7 -P 10 -F 7 -S 10 -x

# batch creating the pbx's audio file using as input a directory containing *.txt files
$NAME -i /tmp/src -o /tmp/dst -m /tmp/music.mp3 -e "$TTS_ENGINE" -v "$TTS_VOICE" -p 7 -P 10 -F 7 -S 10 -x

# synthesize multiple file with different languages using a single pipe line (named MEGAMIX feature)
$NAME -i naturalreaders:Francesca:txt/it/company-it-welcome.txt -i voicerss:en-gb:txt/en/company-en-welcome.txt -o sounds -m audio/musiconhold.mp3 -p 7 -P 10 -F 7 -S 10 -x"
}

# command prompt menu
usage(){
  local progname=$0
  echo "$NAME - $DESCRIPTION
Written by Ugo Viti <ugo.viti@initzero.it>
version: $VERSION released: $VERSION_DATE

usage: $progname [options]

Option:  Argument:           Description:
--------------------------------------------------------------------------------

Input/Output file management:
   -                         Synthesize using standard input
  -t     <text>              Text string to synthesize
  -i     <file or directory> Input txt/wav/mp3 file or directory to synthesize/convert (this disable '-t' option)
  -o     <directory>         Output directory to save synthesized and assembled files (current: $OUT_DIR)

Text To Speech management:
  -e     <engine>            TTS voice engine (current: $TTS_ENGINE)
  -v     <voice>             TTS Voice language (current: $TTS_VOICE)
  -T     <volume>            TTS volume (current: $([ ! -z "$TTS_VOLUME" ] && echo -e -n "$TTS_VOLUME" || echo -e -n "none - use a number from 0.01 to 1"))
  -L                         List usable TTS engines
  -l                         List usable TTS voices

Background music management:
  -m     <file>              Input mp3/wav audio file to use as background music
  -S     <seconds>           Start background music after specified time (current: $MUSIC_START)
  -p     <seconds>           Pad the begin of the TTS audio using the specified time (current: $TTS_PAD_BEGIN sec)
  -P     <seconds>           Pad the end of the TTS audio using the specified time (current: $TTS_PAD_END sec)
  -F     <seconds>           Fade the begin and the end of the wav music using the specified time (current: $MUSIC_FADE sec)
  -M     <volume>            Background music volume (current: $([ ! -z "$MUSIC_VOLUME" ] && echo -e -n "$MUSIC_VOLUME" || echo -e -n "none - use a number from 0.01 to 1"))

Soundcard audio playback options:
  -x                         Playback the generated files using the soundcard speakers (current: $PLAYBACK) (otherwise assemble and save the recordings into output directory)
  -b                         Playback in background detaching the $NAME command (current: $PLAYBACK_BACKGROUND) (only if '-x' = yes)
  -W     <volume>            Change the playback soundcard output volume (current: $([ ! -z "$PLAYBACK_VOLUME" ] && echo -e -n "$PLAYBACK_VOLUME" || echo -e -n "none - use a number from 0 to 100"))
  -r                         Remove synthesized file after playback

Output file options:
  -w                         Overwrite the synthesized file, otherwise keep it (current: $PLAYBACK_RESYNTH)
  -s                         Split destination audio files into audio formats sub directories (current: $SPLIT_OUT_FILE)

Misc options:
  -h                         Display this help menu
  -H                         Display the '$TTS_ENGINE' TTS Engine help menu
  -E                         Display $NAME usage examples
  -V                         Display $NAME version
"
}


###################################################################
#################### default program menu and arguments validations

NO_ARGS=0
E_OPTERROR=65

if [ $# -eq "$NO_ARGS" ]  # Script invoked with no command-line args?
 then
  usage
  exit $E_OPTERROR        # Exit and explain usage, if no argument(s) given.
fi

# Usage: scriptname -options
# Note: dash (-) necessary

while getopts "t:i:o:m:S:p:P:F:M:T:e:v:W:slrLwxbhHEV" option ; do
  case $option in
    t ) # text string to synthesize
        TTS_STRING="${OPTARG}"
        # parse stdin if the special char - is used
        [ "$TTS_STRING" = "-" ] && TTS_STRING="$(cat -)"
        ;;
    i ) # input file or directory to synthesize or convert (create an array with the input files path)
        IN_FILE+=("$OPTARG")
        # parse stdin if the special char - is used
        [ "$IN_FILE" = "-" ] && unset IN_FILE && TTS_STRING="$(cat -)"
        ;;
    o ) # output destination directory to save synthesized text
        OUT_DIR="${OPTARG}"
        ;;
    m ) # wav file to use as background music
        MUSIC_FILE="${OPTARG}"
        ;;
    S ) # start background music after specified seconds
        MUSIC_START="${OPTARG}"
        ;;
    p ) # pad the begin of the TTS audio using the specified time <default 5 sec>
        TTS_PAD_BEGIN="${OPTARG}"
        ;;
    P ) # pad the end of the TTS audio using the specified time <default 5 sec>
        TTS_PAD_END="${OPTARG}"
        ;;
    F ) # fade the begin and the end of the wav music using the specified time <default 10 sec>
        MUSIC_FADE="${OPTARG}"
        ;;
    M ) # music volume attenuation
        MUSIC_VOLUME="${OPTARG}"
	;;
    T ) # TTS volume attenuation
        TTS_VOLUME="${OPTARG}"
	;;
    e ) # use specified voice synthesizer engine
        TTS_ENGINE="${OPTARG}"
	;;
    v ) # use specified voice pack
        TTS_VOICE="${OPTARG}"
	;;
    s ) # split destination audio files into audio formats sub directories
        [ "$SPLIT_OUT_FILE" != "yes" ] && SPLIT_OUT_FILE="yes" || SPLIT_OUT_FILE="no"
	;;
    l ) # list installed TTS voice pack
	make_tmp
	tts_engines_load
	check_tts_engine
        tts_engine_$TTS_ENGINE voices
	exit 0
	;;
    L ) # list installed TTS voice engines synthesizer
        tts_engines_list
	exit 0
	;;
    W ) # change the playback volume
        PLAYBACK_VOLUME="${OPTARG}"
	;;
    r ) # Remove synthesized file after playback
	PLAYBACK_REMOVE="yes"
	;;
    w ) # overWrite the synthesized file
        [ "$PLAYBACK_RESYNTH" != "no" ] && PLAYBACK_RESYNTH="no" || PLAYBACK_RESYNTH="yes"
	;;
    x ) # Assemble and save PBX recordings, otherwise playback the generated files using the soundcard speakers
        [ "$PLAYBACK" != "yes" ] && PLAYBACK="yes" || PLAYBACK="no"
	;;
    b ) # Playback in background detaching the command
        [ "$PLAYBACK_BACKGROUND" != "yes" ] && PLAYBACK_BACKGROUND="yes" || PLAYBACK_BACKGROUND="no"
	;;
    h ) # display this help menu
        usage
	exit 0
	;;
    H ) # display engine help menu
        tts_engine_$TTS_ENGINE help
	exit 0
	;;
    E ) # display usage examples
        usage_examples
	exit 0
	;;
    V ) # display current version
        echo "$VERSION"
        #echo $NAME version: $VERSION released: $VERSION_DATE
	exit 0
	;;
    * )
        usage
        echo "invalid switch specified - abort." >&2
        exit 1
        ;;
  esac
done
# Move argument pointer to next.
shift $(($OPTIND - 1))

# parse the input stream when no options are given or passed as stdin
if [[ "$1" = "-" ]]; then
  TTS_STRING="$(cat)"
elif [[ ! -z "$*" && -z "$TTS_STRING" && -z "$IN_FILE" ]]; then
  TTS_STRING="$*"
fi

main

# if we no error occur, then erase all temp files and directories
trap "rm -rf "${TMP_DIR}" && exit 0 || exit 1" 0

# END
###########################################################################################

# License:
# ============================================================================
# Written by: Ugo Viti <ugo.viti@initzero.it>
# visit http://www.initzero.it for commercial support
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# ============================================================================


# QUICK INSTALL:
# ============================================================================
# CentOS: yum install -y sox lame mplayer curl espeak wine
# Debian: sudo apt-get install -y sox lame mplayer curl espeak wine
# ============================================================================


# TODO:
# ============================================================================
# - add support for automatically no keep long synthesized sentence (>= 255 chars)
# - add support for http://www.vocalware.com (investigating licence issues)
# - add support for http://www.readspeaker.com (investigating licence issues)
# - add support for http://www.acapela-group.com (investigating licence issues)
# ============================================================================


# ChangeLog:
# ============================================================================
# 4.2 - 2016XXXX
# - don't create tts files name longer than 64 chars
# - dynamic voices listing for fromtexttospeech engine (not more static list)

# 4.1 - 20160509
# - added support for auto splitting sentences longer than the supported engine chars
#   each engine now have a TTS_LENGTH variable if engine usage is limited. This feature make possible to sinth very long sentences
# - speedup the synthesizing process avoiding intermediate convertion to wav format when not remizing o megamixing (this gained 500ms in 4 seconds playback)
# - more intuitive feedback when synthesizing
# - changed default engine to 'naturalreaders' and voice 'Peter' (english language)
# - restored google tts support (limited to 160 chars max)
# - added -r option for removing synthesized file after playback
# - added support for stdin as input stream, example:
#    echo this is only a test | izsynth -
# - ispeech tts engine addded (http://www.ispeech.org/)

# 4.0 - 20160427
# - added external engine support (put your TTS engines into $HOME/.config/izsynth/engines/YOURENGINE.conf)
# - changed default engine to voicerss (before using it, get an APIKEY! type izsynth -H for more info)
# - added tts_engine help menu
# - enhanced output logging
# - minor script syntax fixes
# - MEGAMIX feature added (read the examples with -E switch)
# - major izsynth restructuration with added smartness ;)
# - now is possible to change on the fly the output volume for string TTS
# - sox command version check with extra options workarounds
# - addedd support for voicerss TTS engine
# - addedd external config file for override the script variables and use external services APIKEYs

# 3.0 - 20160302
# - project rename from ivrwizard to izsynth
# - some cleanup and restructuration
# - added option -G to sox command to remove samples clipping

# 2.2 - 20151219
# - many improvements and sanity checks
# - added mime type log of generated audio file and made sanity checks to discover synthesizing problems
# - added support for NaturalReader <http://www.naturalreaders.com> engine
# - added support for FromtextToSpeech (Using IVONA Voices) <http://www.fromtexttospeech.com> engine
# - NB. because api change, right now the google voice support is not reliable

# 2.1 - 20151024
# - implemented PLAYBACK_BACKGROUND variable to detach the process when playing the voice
#   (useful when used as TTS engine inside an home automation system)

# 2.0 - 20150908
# - direct playback to audio soundcard support
# - major code cleanup and functions rewrite
# - google voice support (via google translate service)
# - fixes for sox >= 14.4.x

# 1.5 - 20150805
# - changed sapi5 voice assignement (now you must use the name and not the reference number)

# 1.4 - 20130221
# - mp3 convertion fixes

# 1.3 - 20120627
# - first version
# ============================================================================
