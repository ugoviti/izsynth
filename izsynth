#!/bin/bash
# izSynth - TTS/Text To Speech synthesizer, background music overlay assembler and audio file converter for PBX and Home Automation Systems
# Home Page: http://www.initzero.it/products/opensource/izsynth
# GitHub: https://github.com/ugoviti/izsynth
# Written by: Ugo Viti <ugo.viti@initzero.it>
#
# izSynth is a bash script running under Linux, written to automate the synthesis of voices used into izPBX System or for realtime TTS (Text To Speech) used into Home Automation solutions.
# It can use offline synthesis software like Loquendo (using the Wine environment), eSpeak, Festival, VoiceRSS, NaturalReaders, and other popular online web TTS services
# to synthesize audio voices from ASCII text files and automatically merging the audio with background music (mp3 and wav format are supported), adding silences and fade in and out.
#
# For INSTALL, LICENSE, README, HowTo, ChangeLog and Contributors go to the end of this script

###########################################################################################
# script variables
NAME="izsynth"
DESCRIPTION="TTS/Text To Speech synthesizer, background music overlay assembler and audio file converter for PBX and Home Automation Systems"
VERSION="4.8"
VERSION_DATE="20170907"

#####################################
## default suggested user variables to change 
## you can put these variables into $HOME/.config/izsynth/izsynth.conf to override the script variables

# default TTS engine
TTS_ENGINE="naturalreaders"

# default TTS voice (null = let TTS engine to set default voice. it will use english)
TTS_VOICE="Peter"

# resynth the file if it already exist
OUTPUT_OVERWRITE="no"

# remove synthesized file after playback
OUTPUT_REMOVE="no"

# assemble and export converted PBX recordings
EXPORT_AUDIO="no"

# default audio formats
EXPORT_AUDIO_FORMATS="44khz.wav wav gsm ulaw alaw slin"

# split destination audio files into audio formats sub directories
EXPORT_AUDIO_FORMAT_SUBDIR="yes"

# playback instead generate PBX files
PLAYBACK="yes"

# play the file in background, otherwise foreground
PLAYBACK_BACKGROUND="yes"

# command used to play the synthesized audio file (mplayer example)
PLAYBACK_COMMAND="mplayer"

# default playback command options (mplayer example)
#PLAYBACK_COMMAND_OPTS="-quiet -nolirc -noconsolecontrols"

# default playback device (mplayer example)
#PLAYBACK_DEVICE="alsa"

# sound card hardware playback volume (use an integer from 0 to 100)
#PLAYBACK_VOLUME="30"

###########################################################################################
## system variables - edit with care

# default mandatory commands
COMMANDS="curl md5sum file iconv soxi sox lame"

# default base temp directory (comment if you want use the system default directory base, ex. /tmp)
TMP_DIR_BASE="/dev/shm"

# default redirect to tmp dir
OUT_DIR="$TMP_DIR_BASE"

# default TTS volume
#TTS_VOLUME="0.4"

# default wait n. seconds before speaking TTS
TTS_PAD_BEGIN="5"

# default wait n. seconds after speaked TTS
TTS_PAD_END="5"

# default start music after n. seconds
MUSIC_START="0"

# default fade the start and end of music with 5 seconds
MUSIC_FADE="5"

# default music volume
#MUSIC_VOLUME="0.1"

# detect HOME variable if the current shell doesn't set it
#[ -z "$HOME" ] && HOME="$(cd >/dev/null 2>&1; pwd)"
[ -z "$HOME" ] && HOME="$(pwd)"

# read external izsynth config file (used for service API and external variables override)
IZSYNTH_CONFIG_DIR="$HOME/.config/$NAME"
IZSYNTH_CONFIG_FILE="$IZSYNTH_CONFIG_DIR/$NAME.conf"

# make default izsynth config directory if not exist
[ ! -e "$IZSYNTH_CONFIG_DIR/engines" ] && mkdir -p "$IZSYNTH_CONFIG_DIR/engines"
[ -e "$IZSYNTH_CONFIG_FILE" ] && . "$IZSYNTH_CONFIG_FILE"

## compatibility and deprecated variabiles
[ ! -z "$PLAYBACK_OVERWRITE" ] && OUTPUT_OVERWRITE="$PLAYBACK_OVERWRITE"
[ ! -z "$PLAYBACK_REMOVE" ] && OUTPUT_REMOVE="$PLAYBACK_REMOVE"


###########################################################################################
# main script - don't edit anything bellow
###########################################################################################

###########################################################################################
# START TTS ENGINES
# add others TTS engines here

tts_engine_ispeech() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"


  case $ACTION in
        description)
                echo "2016-05-03 Remote iSpeech NO Custom http://www.ispeech.org"
                ;;
        help)
                echo "this engine is limited to 160 chars max"
                ;;
        env)
                # default output file format
                TTS_EXT="mp3"
		# default max allowed chars
		TTS_LENGTH="150"
                # default TTS voice
                [ -z "$TTS_LANGUAGE" ] && TTS_LANGUAGE="English"
                [ -z "$TTS_VOICE" ] && TTS_VOICE="English"
                ;;
        commands)
                echo "curl"
                ;;
        voices)
                # extract languages and voices list and make the output using the following command:
		#curl -s http://www.ispeech.org/html/tts-demo.php | grep "<li class=\"voices\" id=\"" | awk -F "['']" '{print $2" "$3}' | awk -F "[><]" '{print $1" "$4}' | sed 's/&nbsp;//g' | sed 's/);"//g' | column -c1 -t
		echo "Voice                Country     Language    Gender"
		echo "-------------------- ----------- ----------- ------"
		echo "usenglishfemale      US          English     Female
usenglishmale        US          English     Male
ukenglishfemale      UK          English     Female
ukenglishmale        UK          English     Male
auenglishfemale      Australian  English     Female
usspanishfemale      US          Spanish     Female
usspanishmale        US          Spanish     Male
chchinesefemale      China       Chinese     Female
hkchinesefemale      HongKong    Catonese    Female
twchinesefemale      Taiwan      Chinese     Female
jpjapanesefemale     Japan       Japanese    Female
krkoreanfemale       Korea       Korean      Female
caenglishfemale      Canadian    English     Female
huhungarianfemale    Hungary     Hungarian   Female
brportuguesefemale   Brazilian   Portuguese  Female
eurportuguesefemale  European    Portuguese  Female
eurportuguesemale    European    Portuguese  Male
eurspanishfemale     European    Spanish     Female
eurspanishmale       European    Spanish     Male
eurcatalanfemale     European    Catalan     Female
eurczechfemale       European    Czech       Female
eurdanishfemale      European    Danish      Female
eurfinnishfemale     European    Finnish     Female
eurfrenchfemale      European    French      Female
eurfrenchmale        European    French      Male
eurnorwegianfemale   European    Norweigian  Female
eurdutchfemale       European    Dutch       Female
eurpolishfemale      European    Polish      Female
euritalianfemale     European    Italian     Female
euritalianmale       European    Italian     Male
eurturkishfemale     European    Turkish     Female
eurturkishmale       European    Turkish     Male
eurgreekfemale       European    Greek       Female
eurgermanfemale      European    German      Female
eurgermanmale        European    German      Male
rurussianfemale      Russia      Russian     Female
rurussianmale        Russia      Russian     Male
swswedishfemale      Sweden      Swedish     Female
cafrenchfemale       Canadian    French      Female
cafrenchmale         Canadian    French      Male
arabicmale           Dubai       Arabic      Male"
                ;;
        voice)
                eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | awk '{print $1}'
                ;;
        synthesize)
                local TTS_STRING_CONTENT="$(urlencode "$(cat "$IN" | parse_tts_string)")"
                local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"

		curl -s "http://www.ispeech.org/p/generic/getaudio?text=$TTS_STRING_CONTENT&voice=$TTS_VOICE&speed=0&action=convert" -o "$OUT"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}


tts_engine_google() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
        description)
                echo "2016-05-01 Remote GoogleVoice NO Google http://translate.google.com"
                ;;
        help)
                echo "this engine is limited to 160 chars max"
                ;;
        env)
                # default output file format
                TTS_EXT="mp3"
		# default max allowed chars
		TTS_LENGTH="150"
                # default TTS voice
                [ -z "$TTS_VOICE" ] && TTS_VOICE="en"
                ;;
        commands)
                echo "curl"
                ;;
        voices)
		echo "af  Afrikaans
sq  Albanian
am  Amharic
ar  Arabic
hy  Armenian
az  Azerbaijani
eu  Basque
be  Belarusian
bn  Bengali
bh  Bihari
bs  Bosnian
br  Breton
bg  Bulgarian
km  Cambodian
ca  Catalan
zh-CN Chinese (Simplified)
zh-TW Chinese (Traditional)
co  Corsican
hr  Croatian
cs  Czech
da  Danish
nl  Dutch
en  English
eo  Esperanto
et  Estonian
fo  Faroese
tl  Filipino
fi  Finnish
fr  French
fy  Frisian
gl  Galician
ka  Georgian
de  German
el  Greek
gn  Guarani
gu  Gujarati
ha  Hausa
iw  Hebrew
hi  Hindi
hu  Hungarian
is  Icelandic
id  Indonesian
ia  Interlingua
ga  Irish
it  Italian
ja  Japanese
jw  Javanese
kn  Kannada
kk  Kazakh
rw  Kinyarwanda
rn  Kirundi
ko  Korean
ku  Kurdish
ky  Kyrgyz
lo  Laothian
la  Latin
lv  Latvian
ln  Lingala
lt  Lithuanian
mk  Macedonian
mg  Malagasy
ms  Malay
ml  Malayalam
mt  Maltese
mi  Maori
mr  Marathi
mo  Moldavian
mn  Mongolian
sr-ME Montenegrin
ne  Nepali
no  Norwegian
nn  Norwegian (Nynorsk)
oc  Occitan
or  Oriya
om  Oromo
ps  Pashto
fa  Persian
pl  Polish
pt-BR Portuguese (Brazil)
pt-PT Portuguese (Portugal)
pa  Punjabi
qu  Quechua
ro  Romanian
rm  Romansh
ru  Russian
gd  Scots Gaelic
sr  Serbian
sh  Serbo-Croatian
st  Sesotho
sn  Shona
sd  Sindhi
si  Sinhalese
sk  Slovak
sl  Slovenian
so  Somali
es  Spanish
su  Sundanese
sw  Swahili
sv  Swedish
tg  Tajik
ta  Tamil
tt  Tatar
te  Telugu
th  Thai
ti  Tigrinya
to  Tonga
tr  Turkish
tk  Turkmen
tw  Twi
ug  Uighur
uk  Ukrainian
ur  Urdu
uz  Uzbek
vi  Vietnamese
cy  Welsh
xh  Xhosa
yi  Yiddish
yo  Yoruba
zu  Zulu" | sort | column -c1 -t
                ;;
        voice)
                eval ${FUNCNAME} voices | grep -w -- "$VOICE" | head -n1 | awk '{print $1}'
                ;;
        synthesize)
                local TTS_STRING_CONTENT="$(urlencode "$(cat "$IN" | parse_tts_string)")"
                local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"
                curl -s -G "http://translate.google.com/translate_tts?ie=UTF-8&total=1&idx=0&client=tw-ob&&tl=$TTS_VOICE&q=$TTS_STRING_CONTENT" -A "Mozilla" --compressed -o "$OUT"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}


tts_engine_voicerss() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"


  case $ACTION in
        description)
                echo "2016-04-18 Remote VoiceRSS YES Custom http://www.voicerss.org"
                ;;
        help)
                echo "Get the VoiceRSS API KEY from: http://www.voicerss.org/personel"
                echo "and put the following variable info '$IZSYNTH_CONFIG_FILE' config file:"
                echo
                echo "VOICERSS_APIKEY=\"your_api_key_hash_go_here\""
                ;;
        env)
                # default output file format
                TTS_EXT="mp3"
                # default TTS voice
                [ -z "$TTS_LANGUAGE" ] && TTS_LANGUAGE="English"
                [ -z "$TTS_VOICE" ] && TTS_VOICE="English"
                ;;
        commands)
                echo "curl"
                ;;
        voices)
                # extract languages and voices list and make the output
                curl -s "http://www.voicerss.org/api/demo.aspx" | grep "option value=" | grep -v "value=\"\"" | awk -F \" '{print $2 $3}' | awk -F "[><]" '{print $1" "$2}'
                ;;
        voice)
                eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | awk '{print $1}'
                ;;
        synthesize)
                local TTS_STRING_CONTENT="$(urlencode "$(cat "$IN" | parse_tts_string)")"
                local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"
                [ -z "$VOICERSS_APIKEY" ] && echo && print_help_config && exit 1

                curl -s "http://api.voicerss.org/?key=$VOICERSS_APIKEY&src=$TTS_STRING_CONTENT&f=44khz_16bit_mono&hl=$TTS_VOICE" -o "$OUT"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}

tts_engine_naturalreaders() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
	description)
		echo "2017-09-08 Remote NaturalReader YES Custom http://www.naturalreaders.com"
		;;
	help)
		echo "No help available for $TTS_ENGINE"
		;;
	env)
		# default output file format
		TTS_EXT="mp3"
		# default TTS voice
		[ -z "$TTS_VOICE" ] && TTS_VOICE="en"
		;;
	commands)
		echo "curl"
		;;
	voices)
		# extracted from www.naturalreaders.com on 2017-09-08
		# oneliner command:
		# curl -s https://www.naturalreaders.com/online/main.bc6d1a3c4945c5af706b.bundle.js | uglifyjs --beautify | grep ", this.premiumVoices.push(n), " | sed 's/this.premiumVoices.push(n), /'\\\n'/g' | sed -e 's/^[ \t]*//' | sed '/^$/d' | awk -F'[()]' '{print $2}' | sed 's/"//g' | sed 's/ //g' | sort | uniq | awk -F, '{print $2" "$1" "$3" "$4}' | sort | column -c1 -t
		echo "de-DE  Klara     att    6
de-DE  Klaus     aca    28
de-DE  Petra     apple  11
de-DE  Reiner    att    5
de-DE  Sarah     aca    35
de-DE  Yannick   apple  12
en-GB  Audrey    att    3
en-GB  Charles   att    2
en-GB  Daniel    apple  3
en-GB  Graham    aca    25
en-GB  Peter     aca    31
en-GB  Rachel    aca    32
en-GB  Serena    apple  4
en-US  Ava       apple  1
en-US  Mike      att    1
en-US  Rod       aca    41
en-US  Ryan      aca    33
en-US  Samantha  apple  2
en-US  Sharon    aca    42
en-US  Tom       apple  0
en-US  Tracy     aca    37
es-CA  Jorge     apple  8
es-ES  Alberto   att    19
es-ES  Monica    apple  7
es-ES  Rosa      att    20
es-MX  Juan      apple  5
es-MX  Paulina   apple  6
fr-CA  Chantal   apple  10
fr-CA  Louice    aca    43
fr-CA  Nicolas   apple  9
fr-FR  Alain     att    7
fr-FR  Alice     aca    21
fr-FR  Bruno     aca    22
fr-FR  Juliette  att    8
it-IT  Chiara    aca    23
it-IT  Federica  apple  14
it-IT  Luca      apple  13
it-IT  Vittorio  aca    36
nl-NL  Claire    apple  21
pt-BR  Felip     apple  15
pt-BR  Luciana   apple  16
pt-PT  Catarina  apple  17
pt-PT  Celia     aca    44
pt-PT  Joana     apple  18
sv-SE  Alva      apple  19
sv-SE  Emma      aca    45
sv-SE  Erik      aca    46
sv-SE  Oskar     apple  20"
		;;
        voice)
		eval ${FUNCNAME} voices 2>&1 | grep -i -F -w -- "$VOICE" | head -n1 | tr -d [:cntrl:] | awk '{print $4}'
                ;;
	synthesize)
		local TTS_STRING_CONTENT="$(urlencode "$(cat "$IN" | parse_tts_string)")"
		local TTS_SPEED=1
		local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"
		local TTS_TYPE="$(eval ${FUNCNAME} voices 2>&1 | grep -i -F -w -- "$VOICE" | head -n1 | tr -d [:cntrl:] | awk '{print $3}')"
		case $TTS_TYPE in
			aca|att) curl -s -G "http://api.naturalreaders.com/v0/tts/?t=$TTS_STRING_CONTENT&r=$TTS_VOICE&s=$TTS_SPEED" -o "$OUT" ;;
			apple)   curl -s -G "http://api.naturalreaders.com/v4/tts/macspeak?apikey=b98x9xlfs54ws4k0wc0o8g4gwc0w8ss&src=pw&r=$TTS_VOICE&s=$TTS_SPEED&t=$TTS_STRING_CONTENT" -o "$OUT" ;;
		esac

		# deprecated old method
		#local REQUESTTOKEN="$(curl -s -G "http://api.naturalreaders.com/v2/auth/requesttoken?appid=pelc790w2bx&appsecret=2ma3jkhafcyscswg8wgk00w0kwsog4s" | awk -F":" '{print $3}' | tr -d [:punct:])"
		#curl -s -G "http://api.naturalreaders.com/v2/tts/?t=$TTS_STRING_CONTENT&r=$TTS_VOICE&s=$TTS_SPEED&requesttoken=$REQUESTTOKEN" -o "$OUT"
		;;
	*)
		echo "${FUNCNAME}: wrong method called - abort"
		exit 1
		;;
  esac
}


tts_engine_fromtexttospeech() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
	description)
		echo "2015-12-19 Remote FromtextToSpeech NO IVONA http://www.fromtexttospeech.com"
		;;
	help)
		echo "No help available for $TTS_ENGINE"
		;;
	env)
		# default output file format
		TTS_EXT="mp3"
		# default TTS voice
		[ -z "$TTS_LANGUAGE" ] && TTS_LANGUAGE="English"
		[ -z "$TTS_VOICE" ] && TTS_VOICE="English"
		;;
	commands)
		echo "curl"
		;;
	voices)
                curl -s http://www.fromtexttospeech.com | grep "voice_indexes\['" | awk -F = '{print $2}' | sed '/^$/d' | sed "s/ '//" | sed "s/';//"
		;;
        voice)
		eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | tr -d [:cntrl:] | awk -F: '{print $1}'
                ;;
	synthesize)
		local TTS_STRING_CONTENT="$(cat $IN)"
		local TTS_SPEED=0
		local TTS_LANGUAGE="$(eval ${FUNCNAME} voice $VOICE | awk -F "[()]" '{ for (i=2; i<NF; i+=2) print $i }')"
		local TTS_VOICE="$(eval ${FUNCNAME} voice $VOICE)"
                #debug
		local ENGINE_URL="http://www.fromtexttospeech.com"

                local OUTPUT_FIlE="$(curl -s 'http://www.fromtexttospeech.com/' --data-urlencode "input_text=$TTS_STRING_CONTENT" --data-urlencode "language=$TTS_LANGUAGE" --data-urlencode "voice=$TTS_VOICE" --data "speed=$TTS_SPEED&action=process_text" | grep "href='/output/" | sed -n "/href='/s/.*href='\([^>]*\)'.*/\1/p")"
		curl -s $ENGINE_URL$OUTPUT_FIlE -o "$OUT"

		;;
	*)
		echo "${FUNCNAME}: wrong method called - abort"
		exit 1
		;;
  esac
}

tts_engine_festival() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
        description)
                echo "2015-12-19 Local Festival NO OpenSource http://www.cstr.ed.ac.uk/projects/festival"
                ;;
        help)
                echo "No help available for $TTS_ENGINE"
                ;;
        env)
                # default output file format
                TTS_EXT="wav"
                # default TTS voice
                [ -z "$TTS_VOICE" ] && TTS_VOICE="nitech_us_slt_arctic_hts"
                ;;
        commands)
                echo "text2wave"
                ;;
        voices)
                echo "festival voices list not supported"
                echo "run 'festival' command and type: (voice.list)"
                echo "CTRL-D to exit"
                echo "configure the desired language into $HOME/.festivalrc"
                ;;
        voice)
                #eval ${FUNCNAME} voices 2>&1 | grep -w "^$VOICE$"
                echo nitech_us_slt_arctic_hts
                ;;
        synthesize)
                cat "$IN" | text2wave -o "$OUT"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}



tts_engine_espeak() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
	description)
		echo "2015-12-19 Local eSpeak NO OpenSource http://espeak.sourceforge.net"
		;;
	help)
		echo "No help available for $TTS_ENGINE"
		;;
	env)
		# default output file format
		TTS_EXT="wav"
		# default TTS voice
		[ -z "$TTS_VOICE" ] && TTS_VOICE="en"
		;;
	commands)
		echo "espeak"
		;;
	voices)
		espeak --voices | awk '{print $2}' | grep -v ^Language$
		;;
        voice)
                eval ${FUNCNAME} voices 2>&1 | grep -w -- "^$VOICE$"
                ;;
	synthesize)
		espeak -w $OUT -v $TTS_VOICE -f $IN
		;;
	*)
		echo "${FUNCNAME}: wrong method called - abort"
		exit 1
		;;
  esac
}


tts_engine_sapi5() {
  local ACTION="$1"
  shift
  local VOICE="$1"
  shift
  local IN="$1"
  shift
  local OUT="$1"

  case $ACTION in
        description)
                echo "2015-12-19 Local SAPI5 NO Microsoft http://www.microsoft.com/en-us/download/details.aspx?id=10121"
                ;;
	help)
		echo "To use $TTS_ENGINE you must install:"
		echo "- wine (to run Windows applications inside Linux) from http://www.winehq.org/"
		echo "- Microsoft-English-TTS-51.msi (SAPI5 Speech SDK 5.1) from https://www.microsoft.com/en-us/download/details.aspx?id=10121"
		echo "- sapi2wav.exe (Synth and save TTS wav files using Windows SAPI library) from https://gitlab.mister-muffin.de/josch/novel2audio/raw/master/sapi2wav.exe"
		echo "- Buy and install commercial TTS engines for Windows SAPI environment, like Loquendo and IVONA voices"
		;;
	env)
		# default output file format
		TTS_EXT="wav"
		# default TTS voice
		[ -z "$TTS_VOICE" ] && TTS_VOICE="Giulia"
		;;
	commands)
		echo "sapi2wav.exe"
		;;
	voices)
		sapi2wav.exe -list 2>&1 | grep -v "wineboot.exe"
		;;
	voice)
		eval ${FUNCNAME} voices 2>&1 | grep -F -w -- "$VOICE" | head -n1 | tr -d [:cntrl:] | awk -F: '{print $1}'
		;;
	synthesize)
                # convert utf-8 text file to iso-8859-15
                local IN_FILE_ISO8859="$TMP_DIR/$(basename "$IN")"
                iconv --to-code ISO-8859-15 "$IN" -o "$IN_ISO8859" 

		sapi2wav.exe "$OUT" "$(eval ${FUNCNAME} voice $VOICE)" -f "$IN_ISO8859" 2>&1 | grep -v "wineboot.exe"
		;;
	*)
		echo "${FUNCNAME}: wrong method called - abort"
		exit 1
		;;
  esac
}


# END TTS ENGINES
###########################################################################################

###########################################################################################
# START PLAYBACK ENGINES
# add others PLAYBACK engines here

playback_engine_mplayer() {
  local ACTION="$1"
  shift
  local IN="$1"

  case $ACTION in
        description)
		echo "2016-12-18 MPlayer http://www.mplayerhq.hu/"
                ;;
        help)
                echo "MPlayer - The Movie Player"
                echo "MPlayer is a movie player which runs on many systems (see the documentation). It plays most MPEG/VOB, AVI, Ogg/OGM, VIVO, ASF/WMA/WMV, QT/MOV/MP4, RealMedia, Matroska, NUT, NuppelVideo, FLI, YUV4MPEG, FILM, RoQ, PVA files, supported by many native, XAnim, and Win32 DLL codecs. You can watch VideoCD, SVCD, DVD, 3ivx, DivX 3/4/5, WMV and even H.264 movies."
                ;;
        env)
                # set default options
                [ -z "$PLAYBACK_COMMAND_OPTS" ] && PLAYBACK_COMMAND_OPTS+=" -quiet -nolirc -noconsolecontrols -afm mp3lib,ffmpeg"

                # change playback device. default: do not change playback device (suggested: alsa)
                [ -z "$PLAYBACK_DEVICE" ] || PLAYBACK_COMMAND_OPTS+=" -ao $PLAYBACK_DEVICE"

                # change playback volume. default: do not change output volume
                [ -z "$PLAYBACK_VOLUME" ] || PLAYBACK_COMMAND_OPTS+=" -volume $PLAYBACK_VOLUME"
                ;;
        commands)
                echo "mplayer"
                ;;
        play)
                mplayer $PLAYBACK_COMMAND_OPTS "$IN"
                ;;
        *)
                echo "${FUNCNAME}: wrong method called - abort"
                exit 1
                ;;
  esac
}


# END PLAYBACK ENGINES
###########################################################################################


write_default_config() {
echo "# ENGINE SPECIFIC API KEYS
#VOICERSS_APIKEY=\"your_api_key_hash_go_here\"
 
# default tts engine
TTS_ENGINE=\"$TTS_ENGINE\"
 
# default tts voice (null = let tts engine to set default voice. it will use english)
TTS_VOICE=\"$TTS_VOICE\"
 
# resynth the file if it already exist
OUTPUT_OVERWRITE=\"$OUTPUT_OVERWRITE\"

# remove synthesized file after playback
OUTPUT_REMOVE=\"$OUTPUT_REMOVE\"

# assemble and export converted PBX recordings
EXPORT_AUDIO=\"$EXPORT_AUDIO\"

# assemble and export to the following audio formats
EXPORT_AUDIO_FORMATS=\"$EXPORT_AUDIO_FORMATS\"

# split destination audio files into audio formats sub directories
EXPORT_AUDIO_FORMAT_SUBDIR=\"$EXPORT_AUDIO_FORMAT_SUBDIR\"

# realtime audio playback variables
PLAYBACK=\"$PLAYBACK\"
 
# play the file in background, otherwise foreground
PLAYBACK_BACKGROUND=\"$PLAYBACK_BACKGROUND\"

# command used to play the synthesized audio file
PLAYBACK_COMMAND=\"$PLAYBACK_COMMAND\"
 
# default playback command options
PLAYBACK_COMMAND_OPTS=\"$PLAYBACK_COMMAND_OPTS\"
 
# default playback device
PLAYBACK_DEVICE=\"$PLAYBACK_DEVICE\"
 
# sound card playback volume
PLAYBACK_VOLUME=\"$PLAYBACK_VOLUME\"
 
# default base temp directory (comment if you want use the system default directory base, ex. /tmp)
TMP_DIR_BASE=\"$TMP_DIR_BASE\"
 
# default redirect to tmp dir
OUT_DIR=\"$TMP_DIR_BASE\"
 
# default tts volume
TTS_VOLUME=\"$TTS_VOLUME\"
 
# default wait n. seconds before speaking tts
TTS_PAD_BEGIN=\"$TTS_PAD_BEGIN\"
 
# default wait n. seconds after speaked tts
TTS_PAD_END=\"$TTS_PAD_END\"
 
# default start music after n. seconds
MUSIC_START=\"$MUSIC_START\"
 
# default fade the start and end of music with 5 seconds
MUSIC_FADE=\"$MUSIC_FADE\"
 
# default music volume
MUSIC_VOLUME=\"$MUSIC_VOLUME\"
" > "$IZSYNTH_CONFIG_FILE"
}

# load all external TTS engines
tts_engines_load() {
  for engine in $(find "$IZSYNTH_CONFIG_DIR/engines/" -type f -name "*.conf") ; do . $engine ; done
}

# list all supported TTS engines
tts_engines_list(){
  print_tts_engines_table() {
  echo "Engine            Version     Type    Provider          APIKEY  Technology  HomePage"
  echo "----------------  ----------  ------  ----------------  ------  ----------  --------"
  tts_engines_load
  typeset -f | awk '/ \(\) $/ && !/^main / {print $1}' | grep "^tts_engine_" | sed 's/^tts_engine_//g' | while read engine
   do
     echo -n -e "$engine $(tts_engine_$engine description)\n"
   done
  }
  print_tts_engines_table | column -c1 -t
}

# verify if the specified TTS engine exist
tts_engines_check() {
  if [ -z "$1" ] || [ -z "$(tts_engines_list | grep -w "$1")" ] 
    then
 	echo "ERROR: wrong TTS engine synthesizer specified: '$1'"
	echo
	echo "please select an engine from the following list:"
	echo
	tts_engines_list
	exit 1
  fi
}

tts_engines_check_voice() {
  if [ -z "$2" ] || [ -z "$(tts_engine_$1 voice $2)" ] 
    then
	echo "ERROR: the TTS voice '$2' doesn't exist, or is not supported by the engine '$1'"
	echo
	echo "please select a voice from the following list:"
	echo
	tts_engine_$1 voices
	exit 1
  fi
}


# list all supported playback engines
playback_engines_list(){
  print_playback_engines_table() {
  echo "Engine            Version     Name              HomePage"
  echo "----------------  ----------  ----------------  --------"
  typeset -f | awk '/ \(\) $/ && !/^main / {print $1}' | grep "^playback_engine_" | sed 's/^playback_engine_//g' | while read engine
   do
     echo -n -e "$engine $(playback_engine_$engine description)\n"
   done
  }
  print_playback_engines_table | column -c1 -t
}


# verify if the specified playback engine exist
playback_engines_check() {
  if [ -z "$1" ] || [ -z "$(playback_engines_list | grep -w "$1")" ]
    then
 	echo "ERROR: wrong PLAYBACK engine specified: '$1'"
	echo
	echo "please select an engine from the following list:"
	echo
	playback_engines_list
	exit 1
  fi
}



# urlencode <string>
urlencode() {
    local LANG=C
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%%%02X' "'$c" ;; 
        esac
    done
}

# remove all new lines, double white spaces and ending spaces to avoid problems when encoding url
parse_tts_string() {
  tr '\n' ' ' | sed 's/  \+/ /g' | sed 's/^[ \t]*//;s/[ \t]*$//' | sed 's/ *\([[:punct:]]\) */\1 /g'
}

# because some engines allow only limited string length, we must count how many chars we have and pass only the max allowed to the engine
count_chars() {
  tr -d '[:space:]' | wc -c
}


print_help_config() {
  echo "ERROR: Wrong or missing $NAME user config file.

Step 1: Create this file: $IZSYNTH_CONFIG_FILE (use the command $0 -C)
Step 2: Put into all variables you want override from the main script
Step 3: $TTS_ENGINE engine specific config and variables:
"
  tts_engine_$TTS_ENGINE help
}

confirm () {
    # call with a prompt string or use a default
    read -r -p "${1:-Are you sure? [y/N]} " -n 1 response
    case $response in
        [yY][eE][sS]|[yY])
            echo
            true
            ;;
        *)
            echo
            false
            ;;
    esac
}

# print orizontal line with the given length
rulem()  {
  if [ $# -eq 0 ]; then
    echo "Usage: rulem MESSAGE WIDTH [RULE_CHARACTER]"
    return 1
  fi
  # Fill line with ruler character ($3, default "-"), reset cursor, move 2 cols right, print message
  if [ -z "$3" ] ; then
     printf -v _hr "%*s" $(tput cols) && echo -en ${_hr// /${2--}} && echo -e "\r\033[2C$1"
   else
     printf -v _hr "%$3s" && echo -en ${_hr// /${2--}} && echo -e "\r\033[2C$1"
  fi
}

# verify if the given variable is an array
is_array() {
    [[ "$(declare -p $1 2>/dev/null)" =~ "declare -a" ]]
}

# show mime type of a file (long version)
show_mime() {
  file --mime-type -b "$@"
}

# show mime type of a file (brief version)
show_mime_brief() {
  file --mime-type -b "$@" | awk -F"/" '{print $1}'
}

# show size of a file
show_size() {
  du -sh "$@" 2>/dev/null | awk '{print $1}'
}

# the name tell all :)
synthesize_file() {
  local IN="$1"
  shift
  local OUT="$1"

  # tts_engine_* destination_file 
  echo -e -n "Synthesizing - input:[$IN] engine:[${TTS_ENGINE[$ID]}] voice:["${TTS_VOICE[$ID]}"] output:[$OUT] "

  tts_engine_${TTS_ENGINE[$ID]} synthesize "${TTS_VOICE[$ID]}" "$IN" "$OUT"
  local RETVAL=$?

  echo -e -n "size:[$(show_size "$OUT")] type:[$(show_mime "$OUT")] result:"

  #if [[ $RETVAL = 0 && "$(show_mime_brief "$OUT")" == "audio" ]]; then echo -e -n "[SUCCESS]\n" ; else echo -e -n "[ERROR]\n" ; exit 1; fi

  # workaround for some providers that doesn't set to mime type correctly
  if [[ $RETVAL = 0 ]] && [[ "$(show_mime_brief "$OUT")" == "audio" || "$(show_mime_brief "$OUT")" == "application" ]]; then echo -e -n "[SUCCESS]\n" ; else echo -e -n "[ERROR]\n" ; exit 1; fi
}

# playback the synthesized file
playback_file () {
  local IN="$1"

  # verify if the given PLAYBACK_COMMAND engine exist
  playback_engines_check $PLAYBACK_COMMAND

  # load the playback_engine env
  playback_engine_$PLAYBACK_COMMAND env

  # if we must remove the synthesized file, of course we can't remove it if PLAYBACK_BACKGROUND=yes
  [ "$OUTPUT_REMOVE" = "yes" ] && PLAYBACK_BACKGROUND="no"

  echo "Playing      - input:[$IN] command:[$PLAYBACK_COMMAND] options:[$PLAYBACK_COMMAND_OPTS]"

  if [ "$PLAYBACK_BACKGROUND" = "yes" ]
    then
      # do not block the command execution
      #$PLAYBACK_COMMAND $PLAYBACK_COMMAND_OPTS "$IN" 1>/dev/null &
      playback_engine_$PLAYBACK_COMMAND play "$IN" 1>/dev/null &
    else
      # wait playback to finish before exit from izsynth
      #$PLAYBACK_COMMAND $PLAYBACK_COMMAND_OPTS "$IN" 1>/dev/null
      playback_engine_$PLAYBACK_COMMAND play "$IN" 1>/dev/null
  fi
}

# save the file in the output directory
save_file() {
  local IN="$1"
  shift
  local OUT="$1"

  echo "Saving       - input:[$IN] size:[$(show_size "$IN")] output:[$OUT]"
  cp -f "$IN" "$OUT"
}

# convert the input file to wav format
convert_file() {
  local IN="$1"
  shift
  local OUT="$1"
 
  case "$(print_ext $IN)" in
   mp3)
    echo -e -n "Converting   - input:[$IN] input_size:[$(show_size "$IN")] "
    lame --quiet --resample 44.1 --decode "$IN" "$OUT" 2>&1 | grep -v "Can't step back"
    echo -e -n "output:[$OUT] output_size:[$(show_size "$OUT")]\n"
    # let the converted wav file the input file
    IN="$OUT"
    ;;
  esac

  #debug

  # normalize the converted file
  # calc the sample rate of input audio file and convert the input audio file to the best usable sample rate (44100Hz) before processing and mixing with background music
  local IN_SR="$(soxi -r $IN)"
  if [ "$IN_SR" != 44100 ]
    then
      # change the destination file because become 44100hz frequency
      OUT="$(print_path $OUT)/$(print_name $OUT).normalized.44khz.wav"
      # convert to wav 44100 hz the wav file
      sox $SOX_OPTS "$IN" -r 44100 "$OUT"
      local RETVAL=$?
      local OUT_SR="$(soxi -r $OUT)"
      echo "Normalizing  - input:[$IN] input_size:[$(show_size "$IN")] input_rate:[$IN_SR] output_size:[$(show_size "$OUT")] output_rate:[$OUT_SR]"
      # replace the original 22.5khz with the 44.1khz version
      [ $RETVAL = 0 ] && mv -f "$OUT" "$IN"
  elif [[ ! -e "$OUT" || "$IN" != "$OUT" ]]
     then
      cp -a "$IN" "$OUT"
  fi
}

# convert the input file to the asterisk pbx supported formats
export_file() {
  local IN="$1"
  shift
  local OUT_DIR="$1"

  local AUDIO_FORMAT
  local SOX_OPTS_FORMAT

  for AUDIO_FORMAT in $EXPORT_AUDIO_FORMATS
    do
      # set the destination pbx file name
      if [ "$EXPORT_AUDIO_FORMAT_SUBDIR" = "yes" ]
        then
          mkdir -p "$OUT_DIR/$AUDIO_FORMAT"
          local OUT="$OUT_DIR/$AUDIO_FORMAT/$(print_name $IN).$AUDIO_FORMAT"
        else
          local OUT="$OUT_DIR/$(print_name $IN).$AUDIO_FORMAT"
      fi

      case $AUDIO_FORMAT in
                44khz.wav)
                        SOX_OPTS_FORMAT="-t wav -r 44100"
                        ;;
                wav)
                        SOX_OPTS_FORMAT="-t wav -r 8000 -c 1"
                        ;;
                gsm)
                        SOX_OPTS_FORMAT="-t gsm -r 8000 -c 1"
                        ;;
                ulaw)
                        SOX_OPTS_FORMAT="-t ul -r 8000 -c 1"
                        ;;
                alaw)
                        SOX_OPTS_FORMAT="-t al -r 8000 -c 1"
                        ;;
                slin)
                        SOX_OPTS_FORMAT="-t raw -r 8000 -c 1"
                        ;;
      esac

      if [[ ! -e "$OUT" || "$OUTPUT_OVERWRITE" = "yes" ]]; then
        # convert to pbx formats
        sox -V1 $SOX_OPTS "$IN" $SOX_OPTS_FORMAT "$OUT" lowpass 4000

        # display log informations
        echo "Saving PBX   - input:[$IN] output:[$OUT] size:[$(show_size "$OUT")] type:[$(show_mime "$OUT")]"
       else
        echo "File PBX exist - input:[$OUT]"
      fi
  done
}

# remix the file adding background music and audio effects
remix_file() {
  local IN="$1"
  shift
  local OUT="$1"

  # set sox options
  [ ! -z "$TTS_VOLUME" ] && SOX_OPTS="$SOX_OPTS -v $TTS_VOLUME"
  [ ! -z "$MUSIC_VOLUME" ] && SOX_OPTS_MUSIC="$SOX_OPTS_MUSIC -v $MUSIC_VOLUME"

  # calc the total time duration of input audio file
  let local IN_DURATION="$(soxi -s "$IN")/$(soxi -r "$IN")+$TTS_PAD_BEGIN+$TTS_PAD_END"

  #debug

  if [ ! -z "$MUSIC_FILE" ]
    then
      let local TTS_PAD_BEGIN_REAL="$MUSIC_START+$TTS_PAD_BEGIN"
      echo -e -n "Remixing     - input:[$IN] music:[$MUSIC_FILE] music_volume:[$MUSIC_VOLUME] tts_volume:[$TTS_VOLUME] output:[$OUT] "
      # mix tts voice with background music
      sox -V1 $SOX_OPTS_MUSIC -m "$MUSIC_FILE" "| sox $SOX_OPTS $IN -p pad $TTS_PAD_BEGIN_REAL" "$OUT" trim $MUSIC_START fade h $MUSIC_FADE $IN_DURATION $MUSIC_FADE remix 1,2v0.2 1,2v0.2
      local RETVAL=$?
      echo -e -n "size:[$(show_size $OUT)] duration:[$IN_DURATION] result:"
    else
      echo -e -n "Remixing     - input:[$IN] tts_volume:[$TTS_VOLUME] output:[$OUT] "
      # remix without background music
      sox -V1 $SOX_OPTS "$IN" "$OUT"
      local RETVAL=$?
      echo -e -n "size:[$(show_size $OUT)] duration:[$IN_DURATION] result:"
  fi
  if [ $RETVAL = 0 ]; then echo -e -n "[SUCCESS]\n" ; else echo -e -n "[ERROR]\n" ; exit 1; fi
}

# concatenate all input files in a big file
megamix_file() {
  local OUT="$1"
  sox $SOX_OPTS "${IN_FILE_MEGAMIX[@]}" "$OUT"
  echo "Megamixing   - input:[${IN_FILE_MEGAMIX[@]}] output:[$OUT] size:[$(show_size $OUT)]"
}

assemble_file() {
  local IN="$1"
  shift
  local OUT="$1"

  # local variables
  local OUT_TMP="$TMP_DIR/$(print_name $IN).44khz.wav"
  local OUT_TMP_REMIXED="$TMP_DIR/$(print_name $IN).remixed.44khz.wav"
  local OUT_TMP_MEGAMIXED="$TMP_DIR/$(print_name $IN).megamixed.44khz.wav"

  # if the input file is a text file, synthesize it
  case "$(print_ext $IN)" in
    txt)
      # load any external TTS engines
      tts_engines_load

      # verify if the TTS_ENGINE exist
      tts_engines_check ${TTS_ENGINE[$ID]}

      # verify if the selected TTS voice is supported by the TTS engine
      tts_engines_check_voice ${TTS_ENGINE[$ID]} ${TTS_VOICE[$ID]}

      # import global tts_engine variables
      tts_engine_${TTS_ENGINE[$ID]} env

      local TTS_FILE="$TMP_DIR/$(print_name $IN).$TTS_EXT"
      if [[ "$REMIX" = "yes" || "$PLAYBACK" = "no" ]]; then
        synthesize_file "$IN" "$TTS_FILE"
       else
        # to speed up the playback process don't convert and use the wav version, directly use the tts_engine encoding instead
        synthesize_file "$IN" "$OUT"
      fi
      IN="$TTS_FILE"
      ;;
  esac

  # to speed up the playback process don't convert and use the wav version, directly use the tts_engine encoding instead
  if [[ "$REMIX" = "yes" || "$PLAYBACK" = "no" ]]; then
   case "$(print_ext $IN)" in
    txt|wav|mp3)
      # convert and normalize all given files
      convert_file "$IN" "$OUT_TMP"

      # if not megamixing, remix and save all single files
      if [ "$MEGAMIX" != "yes" ]
       then
        if [ "$REMIX" = "yes" ]; then
            remix_file "$OUT_TMP" "$OUT_TMP_REMIXED"
            save_file  "$OUT_TMP_REMIXED" "$OUT"
          else
           [ "$OUT_TMP" != "$OUT" ] && save_file "$OUT_TMP" "$OUT"
       fi
       else
        # save into this global array all files to megamix (synthesized files and input wav/mp3 files)
        IN_FILE_MEGAMIX[$ID]="$OUT_TMP"
        # if this is the last file on megamix array, then make all remixing
        if [ $ID = ${#IN_FILE[@]} ]
         then
          rulem " [$ID/${#IN_FILE[@]}] " - 80
          megamix_file "$OUT_TMP_MEGAMIXED"
          remix_file "$OUT_TMP_MEGAMIXED" "$OUT_TMP_REMIXED"
          save_file  "$OUT_TMP_REMIXED" "$OUT"
       fi
      fi
      ;;
    *)
      echo "ERROR: Invalid file extension found: $(print_ext $IN) input:[$IN]"
      exit 1
      ;;
   esac
  fi
}

# function used to verify the version of sox commmand
check_ver() {
    printf "%03d%03d%03d%03d" $(echo "$@" | tr '.' ' ')
}

# split the generated tts file into many files to bypass the limit of the engine
split_tts_file() {
  local IN="$1"
  shift
  local ID="$1"

  echo "INFO: Maximun allowed chars reached for engine ${TTS_ENGINE[$ID]}. allowed:$TTS_LENGTH - current:$TTS_LENGTH_CUR"

  SID=0 ; while read string ; do
   let SID+=1
   TTS_ENGINE[$SID]="${TTS_ENGINE[$ID]}"
   TTS_VOICE[$SID]="${TTS_VOICE[$ID]}"
   local IN_FILE_SPLIT_TMP="$TMP_DIR/$(print_name "$IN")-$SID.$(print_ext "$IN")"
   IN_FILE_SPLIT+=($IN_FILE_SPLIT_TMP)
   #echo -e -n "$IN_FILE_SPLIT_TMP " ; echo $string 
   echo $string > "$IN_FILE_SPLIT_TMP"
  done < <(echo -e -n "$(cat "$IN" | parse_tts_string | fold -sw $TTS_LENGTH)\n")
  #debug
}

# file name manupilation
print_path() {
  echo ${@%/*}
}

print_fullname() {
  echo ${@##*/}
}

print_name() {
  print_fullname $(echo ${@%.*}) | sed 's/\..*$//g'
}

print_ext() {
  echo ${@##*.}
}

# print debug info
debug() {
  echo "
IN_FILE ARRAY FIRST VALUE = $IN_FILE'
IN_FILE ARRAY ALL VALUES  = ${IN_FILE[@]}

IN_FILE_MEGAMIX ARRAY FIRST VALUE = $IN_FILE_MEGAMIX'
IN_FILE_MEGAMIX ARRAY ALL VALUES  = ${IN_FILE_MEGAMIX[@]}

other variables: 
================
     TMP_DIR = $TMP_DIR
         PWD = $PWD
          IN = $IN
         OUT = $OUT
TTS_LANGUAGE = $TTS_LANGUAGE
   TTS_VOICE = $TTS_VOICE
     IN_FILE = $IN_FILE
    OUT_FILE = $OUT_FILE
     OUT_PBX = $OUT_PBX
     OUT_DIR = $OUT_DIR
       REMIX = $REMIX
     MEGAMIX = $MEGAMIX
"
}

# temp file management
make_tmp() {
  # the main synbak temp directory base name
  TMP_NAME="$NAME-$(date +"%Y%m%d-%H%M%S")"

  # a better way to manage temp directories
  if [ -z "$TMP_DIR_BASE" ]
    then
      TMP_DIR="$(mktemp -d -t "${TMP_NAME}" 2>/dev/null)"
      # for old systems that doesn't understand 'mktemp -t' option
      [ $? -eq 1 ] && TMP_DIR="/tmp/${TMP_NAME}" && mkdir -p "${TMP_DIR}"
      local TMP_DIR_BASE=/tmp
    else
      # make the final temp directory
      TMP_DIR="${TMP_DIR_BASE}/${TMP_NAME}" && mkdir -p "${TMP_DIR}"
  fi

  # change current directory to the temporary directory and make the backup from there
  if [ ! -d "${TMP_DIR}" ] && [ ! -w "${TMP_DIR}" ]
    then
      echo "ERROR: the directory '${TMP_DIR}' doesn't exist" >&2
      echo >&2
      exit 1
  fi
}

check_env() {
  # definig all global variables

  # verify if all commands are installed in the system paths
  #for COMMAND in $COMMANDS $(tts_engine_$TTS_ENGINE commands)
  #  do
  #    which $COMMAND >/dev/null 2>&1
  #    [ $? -ne 0 ] && echo "ERROR: the command '$COMMAND' doesn't exist in any path, please install it and retry" && exit 1
  #  done

  # compatibility workarounds
  local SOX_VER="$(sox --version | awk '{print $3}' | tr -d '[:alpha:]')"
  if [ $(check_ver $SOX_VER) -ge $(check_ver 14.4.0) ]
   then
     #echo "Versione SOX attuale: $SOX_VER"
     SOX_OPTS="-G"
  fi

  # default extension for syntesized files
  TTS_EXT="mp3"

  # import global tts_engine variables (suppress errors if the engine doesn't exist)
  tts_engine_${TTS_ENGINE[$ID]} env >/dev/null 2>&1

  # set default variables
  [ -z "$OUTPUT_OVERWRITE" ] && OUTPUT_OVERWRITE="yes"

  # check if no args are given and make some sanity checks
  [[ -z "${TTS_STRING}" && -z "${IN_FILE}" ]] && echo "ERROR: no text STRING/FILE/DIRECTORY specified, use '-t' or '-i' option - abort." >&2 && exit 1

  # make an input file where paste the given text string
  # [ -n "$TTS_STRING" ] &&  IN_FILE=("$TMP_DIR/$(echo "$TTS_STRING" | sed -e 's/[^A-Za-z0-9_-]/_/g' | cut -c-64).txt") && echo "$TTS_STRING" > "$IN_FILE"
  [ -n "$TTS_STRING" ] &&  IN_FILE=("$TMP_DIR/$(echo "$TTS_STRING" | sed -e 's/[^A-Za-z0-9_-]/_/g' | cut -c-32)-$(echo "$TTS_STRING-$TTS_ENGINE-$TTS_VOICE-$TTS_VOLUME" | cksum | cut -d" " -f1).txt") && echo "$TTS_STRING" > "$IN_FILE"

  #if is_array IN_FILE ; then echo IN_FILE Ã¨ un array; fi
  #[[ -z "${TTS_STRING}" && ! -f "${IN_FILE}" && ! -d "${IN_FILE}" ]] && echo "ERROR: ${IN_FILE}: invalid input file/directory - abort." >&2 && exit 1

  # if input file is a directory then process all files creating the main array
  if [ -d "${IN_FILE}" ]
    then
      # when input is a directory we never magamixing
      MEGAMIX="no"
      IN_FILE_ARRAY=($(find "$IN_FILE" -maxdepth 1 -type f))
    else
      # parse IN_FILE array and recreate special variables
      IN_FILE_ARRAY=("${IN_FILE[@]}")
  fi

  # destroy IN_FILE and recreate the array
  #echo IN_FILE_ARRAY=${IN_FILE_ARRAY[*]}
  unset IN_FILE

  # recreate the array parsing the command line
  ID=0 ; for IN in ${IN_FILE_ARRAY[@]}; do
   let ID+=1
   if echo "$IN" | grep ":" >/dev/null 2>&1
    then
     # parse input files when provided with megamix syntax
     TTS_ENGINE[$ID]="$(echo "$IN" | awk -F ":" '{print $1}')"
     TTS_VOICE[$ID]="$(echo "$IN" | awk -F ":" '{print $2}')"
     IN_FILE[$ID]="$(echo "$IN" | awk -F ":" '{print $3}')"
     #echo ID: $ID - ${IN_FILE[$ID]}
    else
     # parse input files when provided with default syntax
     TTS_ENGINE[$ID]="$TTS_ENGINE"
     TTS_VOICE[$ID]="$TTS_VOICE"
     IN_FILE[$ID]="$IN"
   fi

   # verify if the specified input file exist
   [ ! -e "${IN_FILE[$ID]}" ] && echo "ERROR: '${IN_FILE[$ID]}' invalid input file/directory - abort." >&2 && exit 1
  done

  # TTS_LENGTH auto splitting feature
  # recreate the array if the engine have chars limit, splitting the input file into many sub files
  if [ ! -z "$TTS_LENGTH" ]; then
     #for ((ID=1;ID<=${#IN_FILE[@]};ID++)); do
     ID=0 ; for IN in ${IN_FILE[@]}; do
      if [ "$(print_ext $IN)" = "txt" ]; then
       let ID+=1
       # destroy the original input file and use the splitted version
       unset IN_FILE[$ID]
       #echo
       #echo ID=$ID IN_FILE=${IN_FILE[@]}
       #echo ID=$ID IN_FILE_ARRAY=${IN_FILE_ARRAY[@]}
       TTS_LENGTH_CUR="$(cat "$IN" | parse_tts_string | count_chars)"
       if [ $TTS_LENGTH_CUR -ge $TTS_LENGTH ]; then
         MEGAMIX="yes"
         split_tts_file "$IN" $ID
        else
         TTS_ENGINE[$ID]="${TTS_ENGINE[$ID]}"
         TTS_VOICE[$ID]="${TTS_VOICE[$ID]}"
         IN_FILE_SPLIT+=($IN)
       fi
      fi
    done

    # recreate again the array with all engines, voices and splitted input files
    if [ ! -z "${IN_FILE_SPLIT[*]}" ]; then
     ID=0 ; for IN in ${IN_FILE_SPLIT[@]}; do
      let ID+=1
       # fix me, this doesn't works very well when using the special input file filter: engine:voice:file
       [ -z "${TTS_ENGINE[$ID]}" ] && TTS_ENGINE[$ID]="$TTS_ENGINE"
       [ -z "${TTS_VOICE[$ID]}" ] && TTS_VOICE[$ID]="$TTS_VOICE"
       IN_FILE[$ID]="$IN"
     done
    fi
  fi

  # verify if a music file is given and the file exist
  [[ ! -z "$MUSIC_FILE" && ! -e "$MUSIC_FILE" ]] && echo "ERROR: the music file '$MUSIC_FILE' doesn't exist or isn't readable" && exit 1

  # use MUSIC_VOLUME as TTS_VOLUME when MUSIC_FILE and TTS_VOLUME is not specified
  [[ -z "$MUSIC_FILE" && -z "$TTS_VOLUME" && ! -z "$MUSIC_VOLUME" ]] && TTS_VOLUME="$MUSIC_VOLUME"

  # we will use the tmp base dir for reusability porpouse, because we will speak the audio soound using the internal soundcard and the sintetized audio
  # will be used directly again if exist
  [ -z "${OUT_DIR}" ] && OUT_DIR="$TMP_DIR_BASE" && echo "INFO: no output directory specified, redirecting playback to system soundcard"
  [ ! -d "${OUT_DIR}" ] && echo "ERROR: invalid output directory specified: '${OUT_DIR}' - abort."      >&2 && exit 1
  [ ! -w "${OUT_DIR}" ] && echo "ERROR: not writable output directory specified: '${OUT_DIR}' - abort." >&2 && exit 1

  # if we give a music file, or change the output volume then remix always
  [[ ! -z "$MUSIC_FILE" || ! -z "$TTS_VOLUME" ]] && REMIX="yes" || REMIX="no"

  # if you pass more that one file as input then megamix them
  [[ "$MEGAMIX" != "no" && ${#IN_FILE[@]} -ge 2 ]] && REMIX="yes" && MEGAMIX="yes"
}


# all begin here
main() {
  # disable system wide command aliases if configured
  unalias mv cp 2>/dev/null

  # make temporary files
  make_tmp

  # verify the enveropment if all is good before starting conversion
  check_env

  # convert music file before assembling
  if [[ ! -z "$MUSIC_FILE" && "$(print_ext $MUSIC_FILE)" != "wav" ]]; then
    convert_file "$MUSIC_FILE" "$TMP_DIR/$(print_name $MUSIC_FILE).44khz.wav"
    MUSIC_FILE="$TMP_DIR/$(print_name $MUSIC_FILE).44khz.wav"
  fi

  # assemble all given files processing array contents
  if [ "$MEGAMIX" != "yes" ] ; then
   ID=0 ; for IN in "${IN_FILE[@]}"; do
    let ID+=1
    #debug

    rulem " [$ID/${#IN_FILE[@]}] - $NAME Name:[$(print_name $IN)] " = 80

    # define the output file name
    [ "$REMIX" = "yes" ] && local OUT="$OUT_DIR/$(print_name $IN).44khz.wav" || local OUT="$OUT_DIR/$(print_name $IN).$TTS_EXT"

    # deprecated
    #if   [[ "$PLAYBACK" = "yes" ]]; then
      # to speed up the playback process don't convert and use the wav version, directly use the tts_engine encoding instead
    #  [ "$REMIX" = "yes" ] && local OUT="$OUT_DIR/$(print_name $IN).44khz.wav" || local OUT="$OUT_DIR/$(print_name $IN).$TTS_EXT"
    #elif [[ "$EXPORT_AUDIO" = "yes" && "$OUTPUT_OVERWRITE" = "no" ]]; then
    #  # to speed up the playback process don't convert and use the wav version, directly use the tts_engine encoding instead
    #  [ "$REMIX" = "yes" ] && local OUT="$OUT_DIR/$(print_name $IN).44khz.wav" || local OUT="$OUT_DIR/$(print_name $IN).$TTS_EXT"
    # else
    #  local OUT="$TMP_DIR/$(print_name $IN).44khz.wav"
    #fi

    if [[ -e "$OUT" && "$OUTPUT_OVERWRITE" = "no" ]]; then
        # resynth the audio file only if the previous saved file was corrupted or with wrong format
        if [ "$(show_mime_brief "$OUT")" != "audio" ]; then
        	echo "File exist   - input:[$OUT] status:[corrupted] action:[resinthesizing]"
		assemble_file "$IN" "$OUT"
	else
		#echo "File exist   - input:[$OUT] size:[$(show_size "$OUT")] status:[good]"
		echo "File exist   - input:[$OUT]"
	fi
      else
        assemble_file "$IN" "$OUT"
    fi

    if   [[ "$PLAYBACK" = "yes" && "$EXPORT_AUDIO" = "no"  ]]; then
        playback_file "$OUT"
    elif [[ "$PLAYBACK" = "no"  && "$EXPORT_AUDIO" = "yes" ]]; then
 	export_file "$OUT" "$OUT_DIR"
    fi

    # if required, remove the synthesized file
    [ "$OUTPUT_REMOVE" = "yes" ] && echo "Removing     - output:[$OUT]" && rm -f "$OUT"

    rulem " [$ID/${#IN_FILE[@]}] " - 80
   done
  else
   # the megamix file name is always taken from the first input name
   [ "$PLAYBACK" = "yes" ] && local OUT_MEGAMIX="$OUT_DIR/$(print_name ${IN_FILE[1]}).44khz.wav" || local OUT_MEGAMIX="$TMP_DIR/$(print_name ${IN_FILE[1]}).44khz.wav"

   if [[ ! -e "$OUT_MEGAMIX" || "$OUTPUT_OVERWRITE" = "yes" ]]; then
        # remix all given files in one big file
        ID=0 ; for IN in "${IN_FILE[@]}"; do
         let ID+=1
         rulem " [$ID/${#IN_FILE[@]}] - $NAME Name:[$(print_name $IN)] == MEGAMIX " = 80
         assemble_file "$IN" "$OUT_MEGAMIX"
         rulem " [$ID/${#IN_FILE[@]}] " - 80
        done
   fi

   let ID+=1

   rulem " [$ID/${#IN_FILE[@]}] - $NAME Name:[$(print_name $IN)] " = 80

   if  [[ "$PLAYBACK" = "yes" && "$EXPORT_AUDIO" = "no"  ]]; then
     playback_file "$OUT_MEGAMIX"
   elif [[ "$PLAYBACK" = "no" && "$EXPORT_AUDIO" = "yes" ]]; then
     export_file "$OUT_MEGAMIX" "$OUT_DIR"
   fi

    # if required, remove the synthesized file
    [ "$OUTPUT_REMOVE" = "yes" ] && echo "Removing     - output:[$OUT_MEGAMIX]" && rm -f "$OUT_MEGAMIX"

   rulem " [$ID/${#IN_FILE[@]}] " - 80
 fi
}

usage_examples() {
echo "$NAME usage examples:
--------------------------------------------------------------------------------
# simple command line using script default variables (must set PLAYBACK=yes into $NAME to works)
$NAME Hello World. This is a test message

# sinthesize using standard input as source, useful when using an external command piped to $NAME
echo \"Welcome home, mr Stark\" | $NAME -

# sinthesize using standard input as source, and adding other $NAME options
echo Good morning boss | $NAME -w -m /tmp/music.mp3 -P 10 -F 7 -

# specifing engine and language and reusing the synthesized file for every run (much faster execution)
$NAME -e "$TTS_ENGINE" -v "$TTS_VOICE" -t \"This is only a test\"

# same example but resynthesizing every time the text and overwriting the destination file
$NAME -e "$TTS_ENGINE" -v "$TTS_VOICE" -t \"This is only a test\" -w

# change the output soundcard volume to 80%
$NAME -e "$TTS_ENGINE" -v "$TTS_VOICE" -t \"This is only a test\" -w -W 80

# batch creating the pbx's audio file using an input txt file
$NAME -i /tmp/src/company-welcome.txt -o /tmp/dst -m /tmp/music.mp3 -e "$TTS_ENGINE" -v "$TTS_VOICE" -p 7 -P 10 -F 7 -S 10 -x

# batch creating the pbx's audio file using as input a directory containing *.txt files
$NAME -i /tmp/src -o /tmp/dst -m /tmp/music.mp3 -e "$TTS_ENGINE" -v "$TTS_VOICE" -p 7 -P 10 -F 7 -S 10 -x

# synthesize multiple file with different languages using a single pipe line (named MEGAMIX feature)
$NAME -i naturalreaders:Francesca:txt/it/company-it-welcome.txt -i voicerss:en-gb:txt/en/company-en-welcome.txt -o sounds -m audio/musiconhold.mp3 -p 7 -P 10 -F 7 -S 10 -x"
}

# command prompt menu
usage(){
  local progname=$0
  echo "$NAME - $DESCRIPTION
Written by Ugo Viti <ugo.viti@initzero.it>
version: $VERSION released: $VERSION_DATE

usage: $progname [options]

Option:  Argument:           Description:
--------------------------------------------------------------------------------

Input/Output file management:
   -                         Synthesize using standard input
  -t     <text>              Text string to synthesize
  -i     <file or directory> Input txt/wav/mp3 file or directory to synthesize/convert (this disable '-t' option)
  -o     <directory>         Output directory to save synthesized and assembled files (current: $OUT_DIR)

TextToSpeech management:
  -e     <engine>            TTS voice engine (current: $TTS_ENGINE)
  -v     <voice>             TTS voice language (current: $TTS_VOICE)
  -T     <volume>            TTS volume (current: $([ ! -z "$TTS_VOLUME" ] && echo -e -n "$TTS_VOLUME" || echo -e -n "none) (use a number from 0.01 to 1"))
  -L                         List usable TTS engines
  -l                         List usable TTS voices

Background music management:
  -m     <file>              Input mp3/wav audio file to use as background music
  -S     <seconds>           Start background music after specified time (current: $MUSIC_START sec)
  -p     <seconds>           Pad the begin of the TTS audio using the specified time (current: $TTS_PAD_BEGIN sec)
  -P     <seconds>           Pad the end of the TTS audio using the specified time (current: $TTS_PAD_END sec)
  -F     <seconds>           Fade the begin and the end of the wav music using the specified time (current: $MUSIC_FADE sec)
  -M     <volume>            Background music volume (current: $([ ! -z "$MUSIC_VOLUME" ] && echo -e -n "$MUSIC_VOLUME" || echo -e -n "none) (use a number from 0.01 to 1"))

Soundcard audio playback options:
  -b                         Playback the generated files using the soundcard speakers (current: $PLAYBACK)
  -B                         Playback in background detaching the $NAME command (current: $PLAYBACK_BACKGROUND) (only if PLAYBACK=yes)
  -k                         Playback command (current: $PLAYBACK_COMMAND)
  -K                         Playback command options (current: $([ ! -z "$PLAYBACK_COMMAND_OPTS" ] && echo -e -n "$PLAYBACK_COMMAND_OPTS" || echo -e -n "none"))
  -d                         Playback output device (current: $([ -z "$PLAYBACK_DEVICE" ] && echo -e -n "default"))
  -D                         List available playback output devices
  -W     <volume>            Change the playback soundcard output volume (current: $([ ! -z "$PLAYBACK_VOLUME" ] && echo -e -n "$PLAYBACK_VOLUME" || echo -e -n "none) (use a number from 0 to 100"))
  -r                         Remove synthesized file after playback (current: $OUTPUT_REMOVE) (no = keep the generated high quality audio file for later usage)

Output file options:
  -x                         Export the generated audio file into PBX formats (current: $EXPORT_AUDIO) (yes = this will assume PLAYBACK=no and OUTPUT_OVERWRITE=yes)
  -X                         Export using the following audio formats (current: \"$EXPORT_AUDIO_FORMATS\") (valid only if EXPORT_AUDIO=yes))
  -w                         Overwrite the synthesized file (current: $OUTPUT_OVERWRITE)
  -s                         Split destination audio files into audio formats sub directories (current: $EXPORT_AUDIO_FORMAT_SUBDIR) (valid only if EXPORT_AUDIO=yes)

Misc options:
  -C                         Write/Overwrite the config file using the command arguments or the default izsynth variables (file: $IZSYNTH_CONFIG_FILE)
  -h                         Display this help menu
  -H                         Display the '$TTS_ENGINE' TTS Engine help menu
  -E                         Display $NAME usage examples
  -V                         Display $NAME version
"
}


###################################################################
#################### default program menu and arguments validations

NO_ARGS=0
E_OPTERROR=65

if [ $# -eq "$NO_ARGS" ]  # Script invoked with no command-line args?
 then
  usage
  exit $E_OPTERROR        # Exit and explain usage, if no argument(s) given.
fi

# Usage: scriptname -options
# Note: dash (-) necessary

while getopts "t:i:o:m:S:p:P:F:M:T:e:v:d:k:K:W:X:slLrxwbBDChHEV" option ; do
  case $option in
    t) # text string to synthesize
        TTS_STRING="${OPTARG}"
        # parse stdin if the special char - is used
        [ "$TTS_STRING" = "-" ] && TTS_STRING="$(cat -)"
        ;;
    i) # input file or directory to synthesize or convert (create an array with the input files path)
        IN_FILE+=("$OPTARG")
        # parse stdin if the special char - is used
        [ "$IN_FILE" = "-" ] && unset IN_FILE && TTS_STRING="$(cat -)"
        ;;
    o) # output destination directory to save synthesized text
        OUT_DIR="${OPTARG}"
        ;;
    m) # wav file to use as background music
        MUSIC_FILE="${OPTARG}"
        ;;
    S) # start background music after specified seconds
        MUSIC_START="${OPTARG}"
        ;;
    p) # pad the begin of the TTS audio using the specified time <default 5 sec>
        TTS_PAD_BEGIN="${OPTARG}"
        ;;
    P) # pad the end of the TTS audio using the specified time <default 5 sec>
        TTS_PAD_END="${OPTARG}"
        ;;
    F) # fade the begin and the end of the wav music using the specified time <default 10 sec>
        MUSIC_FADE="${OPTARG}"
        ;;
    M) # music volume attenuation
        MUSIC_VOLUME="${OPTARG}"
	;;
    T) # TTS volume attenuation
        TTS_VOLUME="${OPTARG}"
	;;
    e) # use specified voice synthesizer engine
        TTS_ENGINE="${OPTARG}"
	;;
    v) # use specified voice pack
        TTS_VOICE="${OPTARG}"
	;;
    s) # split destination audio files into audio formats sub directories
        [ "$EXPORT_AUDIO_FORMAT_SUBDIR" != "yes" ] && EXPORT_AUDIO_FORMAT_SUBDIR="yes" || EXPORT_AUDIO_FORMAT_SUBDIR="no"
	;;
    l) # list installed TTS voice pack
	tts_engines_load
	tts_engines_check $TTS_ENGINE
        tts_engine_$TTS_ENGINE voices
	exit 0
	;;
    L) # list installed TTS voice engines synthesizer
        tts_engines_list
	exit 0
	;;
    W) # change the playback volume
        PLAYBACK_VOLUME="${OPTARG}"
	;;
    r) # remove synthesized file after playback
	OUTPUT_REMOVE="yes"
	;;
    x) # assemble and export converted PBX recordings
        [ "$EXPORT_AUDIO" != "yes" ] && EXPORT_AUDIO="yes" || EXPORT_AUDIO="no"
	PLAYBACK="no"
	;;
    X) # exported file format
        xEXPORT_AUDIO_FORMATS="${OPTARG}"
	if [ -z "$(echo "$EXPORT_AUDIO_FORMATS" | grep -w "$xEXPORT_AUDIO_FORMATS")" ]; then
          echo "Invalid audio format specified: $xEXPORT_AUDIO_FORMATS"
	  echo "Supported audio formats: \"$EXPORT_AUDIO_FORMATS\""
          exit 1
	 else
	  EXPORT_AUDIO_FORMATS="$xEXPORT_AUDIO_FORMATS"
	fi
	;;
    w) # overWrite the synthesized file
        [ "$OUTPUT_OVERWRITE" != "no" ] && OUTPUT_OVERWRITE="no" || OUTPUT_OVERWRITE="yes"
	;;
    b) # playback the generated files using the soundcard speakers
        [ "$PLAYBACK" != "yes" ] && PLAYBACK="yes" || PLAYBACK="no"
	;;
    B) # Playback in background detaching the command
        [ "$PLAYBACK_BACKGROUND" != "yes" ] && PLAYBACK_BACKGROUND="yes" || PLAYBACK_BACKGROUND="no"
	;;
    d) # hardware playback device
        PLAYBACK_DEVICE="${OPTARG}"
	;;
    D) # list hardware playback devices (alsa-utils package must be installed)
	list_playback_devices() {
	 echo "Device: Description:"
	 echo "------- ------------"
         aplay -l | grep ^card | while read devices ; do
          card=$(echo $devices | awk '{print $2}' | tr -d ":")
          device=$(echo $devices | awk -F", " '{print $2}' | awk '{print $2}' | tr -d ":")
          description=$(echo $devices | sed 's/\[/(/g' | sed 's/\]/)/g' | awk -F "[()]" '{print $4}' | sed 's/ /-/g')
          echo "alsa:device=hw=$card.$device     $description"
         done
	 # list all user custom software devices
	 cat $HOME/.asoundrc 2>/dev/null | grep ^pcm | awk '{print "alsa:device="$1}' | sed 's/pcm.//'
	} 
        list_playback_devices | column -c1 -t

	exit 0
	;;
    k) # playback command
        PLAYBACK_COMMAND="${OPTARG}"
	;;
    K) # playback command extra options
        PLAYBACK_COMMAND_OPTS="${OPTARG}"
	;;
    C) # write/overwrite user config file
        if [ -e "$IZSYNTH_CONFIG_FILE" ]; then
          echo "WARNING: the user config file '$IZSYNTH_CONFIG_FILE' already exist"
	  confirm "Do you want overwrite it? [y/N]:" && write_default_config
          [ $? = 0 ] && echo "'$IZSYNTH_CONFIG_FILE' config file written successfully" || echo "ERROR writing '$IZSYNTH_CONFIG_FILE' config file"
         else
          write_default_config
          [ $? = 0 ] && echo "'$IZSYNTH_CONFIG_FILE' config file written successfully" || echo "ERROR writing '$IZSYNTH_CONFIG_FILE' config file"
        fi
	exit 0
	;;
    h) # display this help menu
        usage
	exit 0
	;;
    H) # display engine help menu
        tts_engine_$TTS_ENGINE help
	exit 0
	;;
    E) # display usage examples
        usage_examples
	exit 0
	;;
    V) # display current version
        echo "$VERSION"
        #echo $NAME version: $VERSION released: $VERSION_DATE
	exit 0
	;;
    *)
        usage
        echo "invalid switch specified - abort." >&2
        exit 1
        ;;
  esac
done
# Move argument pointer to next.
shift $(($OPTIND - 1))

# parse the input stream when no options are given or passed as stdin
if [[ "$1" = "-" ]]; then
  TTS_STRING="$(cat)"
elif [[ ! -z "$*" && -z "$TTS_STRING" && -z "$IN_FILE" ]]; then
  TTS_STRING="$*"
fi

# here begin the running of izsynth
main

# if we no error occur, then cleanup all temporary files and directories
trap "rm -rf "${TMP_DIR}" && exit 0 || exit 1" 0

# END
###########################################################################################

# License:
# ============================================================================
# Written by: Ugo Viti <ugo.viti@initzero.it>
# visit http://www.initzero.it for commercial support
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# ============================================================================


# QUICK INSTALL:
# ============================================================================
# CentOS: yum install -y sox lame mplayer curl espeak wine
# Debian: sudo apt-get install -y sox lame mplayer curl espeak wine
# ============================================================================


# TODO:
# ============================================================================
# - add support for automatically no keep long synthesized sentences (>= 255 chars)
# - add support for http://www.vocalware.com (investigating licence issues)
# - add support for http://www.readspeaker.com (investigating licence issues)
# - add support for http://www.acapela-group.com (investigating licence issues)
# ============================================================================


# ChangeLog:
# ============================================================================
# 4.8 - 20170907
# - Implemented cksum hash file names when creating tts files from cli (thanks to Jean-Marc Leglise for the idea). So every txt/tts file will always have an unique file name based on contents.

# 4.7 - 20170428
# - renamed command line option: -x to -b
# - renamed command line option: -b to -B
# - renamed PLAYBACK_OVERWRITE variable to OUTPUT_OVERWRITE
# - renamed PLAYBACK_REMOVE variable to OUTPUT_REMOVE
# - new config file variable: EXPORT_AUDIO and new option switch: -x (assemble and save PBX recordings)
# - new config file variable: EXPORT_AUDIO_FORMATS and new option switch: -X
# - fix print_name function

# 4.6 - 20161228
# - some sox command optimizations
# - add sox "lowpass 4000" when converting to pbx format for better results

# 4.5 - 20161218
# - introduced playback engines (currently implemented mplayer only)
# - many script refactoring

# 4.4 - 20161028
# - implemented -C option to write/overwrite the izsynth user config file
# - some sanity checks to detect the $HOME directory of user

# 4.3 - 20160618
# - implemented PLAYBACK_DEVICE and new -d (specify the output device) -D (list available output devices) options
# - is now possibile to override the playback command (-k) and playback command options (-K)
# - help menu enhancements

# 4.2 - 20160524
# - don't create tts files name longer than 64 chars
# - dynamic voices listing for fromtexttospeech engine (not more static list)
# - some code cleanup

# 4.1 - 20160509
# - added support for auto splitting sentences longer than the supported engine chars
#   each engine now have a TTS_LENGTH variable if engine usage is limited. This feature make possible to sinth very long sentences
# - speedup the synthesizing process avoiding intermediate convertion to wav format when not remizing o megamixing (this gained 500ms in 4 seconds playback)
# - more intuitive feedback when synthesizing
# - changed default engine to 'naturalreaders' and voice 'Peter' (english language)
# - restored google tts support (limited to 160 chars max)
# - added -r option for removing synthesized file after playback
# - added support for stdin as input stream, example:
#    echo this is only a test | izsynth -
# - ispeech tts engine addded (http://www.ispeech.org/)

# 4.0 - 20160427
# - added external engine support (put your TTS engines into $HOME/.config/izsynth/engines/YOURENGINE.conf)
# - changed default engine to voicerss (before using it, get an APIKEY! type izsynth -H for more info)
# - added tts_engine help menu
# - enhanced output logging
# - minor script syntax fixes
# - MEGAMIX feature added (read the examples with -E switch)
# - major izsynth restructuration with added smartness ;)
# - now is possible to change on the fly the output volume for string TTS
# - sox command version check with extra options workarounds
# - addedd support for voicerss TTS engine
# - addedd external config file for override the script variables and use external services APIKEYs

# 3.0 - 20160302
# - project rename from ivrwizard to izsynth
# - some cleanup and restructuration
# - added option -G to sox command to remove samples clipping

# 2.2 - 20151219
# - many improvements and sanity checks
# - added mime type log of generated audio file and made sanity checks to discover synthesizing problems
# - added support for NaturalReader <http://www.naturalreaders.com> engine
# - added support for FromtextToSpeech (Using IVONA Voices) <http://www.fromtexttospeech.com> engine
# - NB. because api change, right now the google voice support is not reliable

# 2.1 - 20151024
# - implemented PLAYBACK_BACKGROUND variable to detach the process when playing the voice
#   (useful when used as TTS engine inside an home automation systemi for not blocking commands execution)

# 2.0 - 20150908
# - direct playback to audio soundcard support
# - major code cleanup and functions rewrite
# - google voice support (via google translate service)
# - fixes for sox >= 14.4.x

# 1.5 - 20150805
# - changed sapi5 voice assignment (now you must use the name and not the voice id number)

# 1.4 - 20130221
# - mp3 convertion fixes

# 1.3 - 20120627
# - first public version
# ============================================================================
